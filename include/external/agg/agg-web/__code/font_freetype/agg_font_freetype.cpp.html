<HTML><HEAD><TITLE>Anti-Grain Geometry - </TITLE>
<META http-equiv="Content-Type" content="text/html"/>
<LINK rel="stylesheet" type="text/css" href="../../agg.styles.css"/>
</HEAD>
<TABLE width="640px" border="0" cellspacing="0" cellpadding="0"><TR><TD><PRE><SPAN class="rem">//----------------------------------------------------------------------------</SPAN>
<SPAN class="rem">// Anti-Grain Geometry (AGG) - Version 2.5</SPAN>
<SPAN class="rem">// A high quality rendering engine for C++</SPAN>
<SPAN class="rem">// Copyright (C) 2002-2006 Maxim Shemanarev</SPAN>
<SPAN class="rem">// Contact: mcseem@antigrain.com</SPAN>
<SPAN class="rem">//          mcseemagg@yahoo.com</SPAN>
<SPAN class="rem">//          http://antigrain.com</SPAN>
<SPAN class="rem">// </SPAN>
<SPAN class="rem">// AGG is free software; you can redistribute it and/or</SPAN>
<SPAN class="rem">// modify it under the terms of the GNU General Public License</SPAN>
<SPAN class="rem">// as published by the Free Software Foundation; either version 2</SPAN>
<SPAN class="rem">// of the License, or (at your option) any later version.</SPAN>
<SPAN class="rem">// </SPAN>
<SPAN class="rem">// AGG is distributed in the hope that it will be useful,</SPAN>
<SPAN class="rem">// but WITHOUT ANY WARRANTY; without even the implied warranty of</SPAN>
<SPAN class="rem">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</SPAN>
<SPAN class="rem">// GNU General Public License for more details.</SPAN>
<SPAN class="rem">// </SPAN>
<SPAN class="rem">// You should have received a copy of the GNU General Public License</SPAN>
<SPAN class="rem">// along with AGG; if not, write to the Free Software</SPAN>
<SPAN class="rem">// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, </SPAN>
<SPAN class="rem">// MA 02110-1301, USA.</SPAN>
<SPAN class="rem">//----------------------------------------------------------------------------</SPAN>

<SPAN class="kw2">#include</SPAN> <SPAN class="op">&lt;</SPAN>stdio<SPAN class="op">.</SPAN>h<SPAN class="op">&gt;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="agg_font_freetype.h.html">agg_font_freetype.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../include/agg_bitset_iterator.h.html">agg_bitset_iterator.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../include/agg_renderer_scanline.h.html">agg_renderer_scanline.h</A>&quot;</SPAN>


<SPAN class="kw1">namespace</SPAN> agg
<SPAN class="op">{</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------------</SPAN>
    <SPAN class="rem">//</SPAN>
    <SPAN class="rem">// This code implements the AUTODIN II polynomial</SPAN>
    <SPAN class="rem">// The variable corresponding to the macro argument &quot;crc&quot; should</SPAN>
    <SPAN class="rem">// be an unsigned long.</SPAN>
    <SPAN class="rem">// Oroginal code  by Spencer Garrett &lt;srg@quick.com&gt;</SPAN>
    <SPAN class="rem">//</SPAN>

    <SPAN class="rem">// generated using the AUTODIN II polynomial</SPAN>
    <SPAN class="rem">//   x^32 + x^26 + x^23 + x^22 + x^16 +</SPAN>
    <SPAN class="rem">//   x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x^1 + 1</SPAN>
    <SPAN class="rem">//</SPAN>
    <SPAN class="rem">//------------------------------------------------------------------------------</SPAN>

    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">const</SPAN> <SPAN class="kw1">unsigned</SPAN> crc32tab<SPAN class="op">[</SPAN><SPAN class="num">256</SPAN><SPAN class="op">]</SPAN> <SPAN class="op">=</SPAN> 
    <SPAN class="op">{</SPAN>
       <SPAN class="num">0x00000000</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x77073096</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xee0e612c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x990951ba</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x076dc419</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x706af48f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe963a535</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9e6495a3</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x0edb8832</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x79dcb8a4</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe0d5e91e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x97d2d988</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x09b64c2b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x7eb17cbd</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe7b82d07</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x90bf1d91</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x1db71064</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x6ab020f2</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf3b97148</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x84be41de</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x1adad47d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x6ddde4eb</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf4d4b551</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x83d385c7</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x136c9856</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x646ba8c0</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xfd62f97a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8a65c9ec</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x14015c4f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x63066cd9</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xfa0f3d63</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8d080df5</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x3b6e20c8</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4c69105e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd56041e4</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa2677172</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x3c03e4d1</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4b04d447</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd20d85fd</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa50ab56b</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x35b5a8fa</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x42b2986c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xdbbbc9d6</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xacbcf940</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x32d86ce3</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x45df5c75</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xdcd60dcf</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xabd13d59</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x26d930ac</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x51de003a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc8d75180</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xbfd06116</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x21b4f4b5</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x56b3c423</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xcfba9599</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb8bda50f</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x2802b89e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5f058808</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc60cd9b2</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb10be924</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x2f6f7c87</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x58684c11</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc1611dab</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb6662d3d</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x76dc4190</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x01db7106</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x98d220bc</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xefd5102a</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x71b18589</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x06b6b51f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9fbfe4a5</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe8b8d433</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x7807c9a2</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x0f00f934</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9609a88e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe10e9818</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x7f6a0dbb</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x086d3d2d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x91646c97</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe6635c01</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x6b6b51f4</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x1c6c6162</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x856530d8</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf262004e</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x6c0695ed</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x1b01a57b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8208f4c1</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf50fc457</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x65b0d9c6</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x12b7e950</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8bbeb8ea</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xfcb9887c</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x62dd1ddf</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x15da2d49</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8cd37cf3</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xfbd44c65</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x4db26158</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x3ab551ce</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa3bc0074</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd4bb30e2</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x4adfa541</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x3dd895d7</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa4d1c46d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd3d6f4fb</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x4369e96a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x346ed9fc</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xad678846</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xda60b8d0</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x44042d73</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x33031de5</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xaa0a4c5f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xdd0d7cc9</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x5005713c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x270241aa</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xbe0b1010</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc90c2086</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x5768b525</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x206f85b3</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb966d409</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xce61e49f</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x5edef90e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x29d9c998</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb0d09822</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc7d7a8b4</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x59b33d17</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x2eb40d81</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb7bd5c3b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc0ba6cad</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xedb88320</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9abfb3b6</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x03b6e20c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x74b1d29a</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xead54739</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9dd277af</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x04db2615</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x73dc1683</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xe3630b12</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x94643b84</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x0d6d6a3e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x7a6a5aa8</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xe40ecf0b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9309ff9d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x0a00ae27</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x7d079eb1</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xf00f9344</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8708a3d2</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x1e01f268</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x6906c2fe</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xf762575d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x806567cb</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x196c3671</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x6e6b06e7</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xfed41b76</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x89d32be0</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x10da7a5a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x67dd4acc</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xf9b9df6f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8ebeeff9</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x17b7be43</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x60b08ed5</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xd6d6a3e8</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa1d1937e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x38d8c2c4</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4fdff252</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xd1bb67f1</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa6bc5767</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x3fb506dd</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x48b2364b</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xd80d2bda</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xaf0a1b4c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x36034af6</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x41047a60</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xdf60efc3</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa867df55</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x316e8eef</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4669be79</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xcb61b38c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xbc66831a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x256fd2a0</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5268e236</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xcc0c7795</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xbb0b4703</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x220216b9</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5505262f</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xc5ba3bbe</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb2bd0b28</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x2bb45a92</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5cb36a04</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xc2d7ffa7</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb5d0cf31</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x2cd99e8b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5bdeae1d</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x9b64c2b0</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xec63f226</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x756aa39c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x026d930a</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x9c0906a9</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xeb0e363f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x72076785</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x05005713</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x95bf4a82</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe2b87a14</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x7bb12bae</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x0cb61b38</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x92d28e9b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe5d5be0d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x7cdcefb7</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x0bdbdf21</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x86d3d2d4</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf1d4e242</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x68ddb3f8</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x1fda836e</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x81be16cd</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf6b9265b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x6fb077e1</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x18b74777</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x88085ae6</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xff0f6a70</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x66063bca</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x11010b5c</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x8f659eff</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf862ae69</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x616bffd3</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x166ccf45</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xa00ae278</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd70dd2ee</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4e048354</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x3903b3c2</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xa7672661</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd06016f7</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4969474d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x3e6e77db</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xaed16a4a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd9d65adc</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x40df0b66</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x37d83bf0</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xa9bcae53</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xdebb9ec5</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x47b2cf7f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x30b5ffe9</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xbdbdf21c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xcabac28a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x53b39330</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x24b4a3a6</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xbad03605</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xcdd70693</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x54de5729</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x23d967bf</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xb3667a2e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc4614ab8</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5d681b02</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x2a6f2b94</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xb40bbe37</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc30c8ea1</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5a05df1b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x2d02ef8d</SPAN><SPAN class="op">,</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>


    <SPAN class="rem">//------------------------------------------------------------------------------</SPAN>

    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">unsigned</SPAN> calc_crc32<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">unsigned</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> buf<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> size<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">unsigned</SPAN> crc <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN><SPAN class="op">)</SPAN>~<SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">const</SPAN> <SPAN class="kw1">unsigned</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> p<SPAN class="op">;</SPAN>
        <SPAN class="kw1">unsigned</SPAN> len <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> 
        <SPAN class="kw1">unsigned</SPAN> nr <SPAN class="op">=</SPAN> size<SPAN class="op">;</SPAN>

        <SPAN class="kw1">for</SPAN> <SPAN class="op">(</SPAN>len <SPAN class="op">+=</SPAN> nr<SPAN class="op">,</SPAN> p <SPAN class="op">=</SPAN> buf<SPAN class="op">;</SPAN> nr<SPAN class="op">--</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">++</SPAN>p<SPAN class="op">)</SPAN> 
        <SPAN class="op">{</SPAN>
            crc <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>crc <SPAN class="op">&gt;&gt;</SPAN> <SPAN class="num">8</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">^</SPAN> crc32tab<SPAN class="op">[</SPAN><SPAN class="op">(</SPAN>crc <SPAN class="op">^</SPAN> <SPAN class="op">*</SPAN>p<SPAN class="op">)</SPAN> <SPAN class="op">&amp;</SPAN> <SPAN class="num">0xff</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> ~crc<SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">inline</SPAN> <SPAN class="kw1">int</SPAN> dbl_to_plain_fx<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> d<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>d <SPAN class="op">*</SPAN> <SPAN class="num">65536</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">inline</SPAN> <SPAN class="kw1">double</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN> p<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">double</SPAN><SPAN class="op">(</SPAN>p<SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> <SPAN class="num">64</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">inline</SPAN> <SPAN class="kw1">int</SPAN> dbl_to_int26p6<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> p<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>p <SPAN class="op">*</SPAN> <SPAN class="num">64</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">5</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> PathStorage<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">bool</SPAN> decompose_ft_outline<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> FT_Outline<SPAN class="op">&amp;</SPAN> outline<SPAN class="op">,</SPAN>
                              <SPAN class="kw1">bool</SPAN> flip_y<SPAN class="op">,</SPAN>
                              <SPAN class="kw1">const</SPAN> <A href="../include/agg_trans_affine.h.html#trans_affine">trans_affine</A><SPAN class="op">&amp;</SPAN> mtx<SPAN class="op">,</SPAN>
                              PathStorage<SPAN class="op">&amp;</SPAN> path<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>   
        <SPAN class="kw1">typedef</SPAN> <SPAN class="kw1">typename</SPAN> PathStorage::value_type value_type<SPAN class="op">;</SPAN>

        FT_Vector   v_last<SPAN class="op">;</SPAN>
        FT_Vector   v_control<SPAN class="op">;</SPAN>
        FT_Vector   v_start<SPAN class="op">;</SPAN>
        <SPAN class="kw1">double</SPAN> x1<SPAN class="op">,</SPAN> y1<SPAN class="op">,</SPAN> x2<SPAN class="op">,</SPAN> y2<SPAN class="op">,</SPAN> x3<SPAN class="op">,</SPAN> y3<SPAN class="op">;</SPAN>

        FT_Vector<SPAN class="op">*</SPAN>  point<SPAN class="op">;</SPAN>
        FT_Vector<SPAN class="op">*</SPAN>  limit<SPAN class="op">;</SPAN>
        <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN>       tags<SPAN class="op">;</SPAN>

        <SPAN class="kw1">int</SPAN>   n<SPAN class="op">;</SPAN>         <SPAN class="rem">// index of contour in outline</SPAN>
        <SPAN class="kw1">int</SPAN>   first<SPAN class="op">;</SPAN>     <SPAN class="rem">// index of first point in contour</SPAN>
        <SPAN class="kw1">char</SPAN>  tag<SPAN class="op">;</SPAN>       <SPAN class="rem">// current point&#039;s state</SPAN>

        first <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>n <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> n <SPAN class="op">&lt;</SPAN> outline<SPAN class="op">.</SPAN>n_contours<SPAN class="op">;</SPAN> n<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">int</SPAN>  last<SPAN class="op">;</SPAN>  <SPAN class="rem">// index of last point in contour</SPAN>

            last  <SPAN class="op">=</SPAN> outline<SPAN class="op">.</SPAN>contours<SPAN class="op">[</SPAN>n<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
            limit <SPAN class="op">=</SPAN> outline<SPAN class="op">.</SPAN>points <SPAN class="op">+</SPAN> last<SPAN class="op">;</SPAN>

            v_start <SPAN class="op">=</SPAN> outline<SPAN class="op">.</SPAN>points<SPAN class="op">[</SPAN>first<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
            v_last  <SPAN class="op">=</SPAN> outline<SPAN class="op">.</SPAN>points<SPAN class="op">[</SPAN>last<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>

            v_control <SPAN class="op">=</SPAN> v_start<SPAN class="op">;</SPAN>

            point <SPAN class="op">=</SPAN> outline<SPAN class="op">.</SPAN>points <SPAN class="op">+</SPAN> first<SPAN class="op">;</SPAN>
            tags  <SPAN class="op">=</SPAN> outline<SPAN class="op">.</SPAN>tags  <SPAN class="op">+</SPAN> first<SPAN class="op">;</SPAN>
            tag   <SPAN class="op">=</SPAN> FT_CURVE_TAG<SPAN class="op">(</SPAN>tags<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="rem">// A contour cannot start with a cubic control point!</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>tag <SPAN class="op">==</SPAN> FT_CURVE_TAG_CUBIC<SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="rem">// check first point to determine origin</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN> tag <SPAN class="op">==</SPAN> FT_CURVE_TAG_CONIC<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="rem">// first point is conic control.  Yes, this happens.</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>FT_CURVE_TAG<SPAN class="op">(</SPAN>outline<SPAN class="op">.</SPAN>tags<SPAN class="op">[</SPAN>last<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">==</SPAN> FT_CURVE_TAG_ON<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="rem">// start at last point if it is on the curve</SPAN>
                    v_start <SPAN class="op">=</SPAN> v_last<SPAN class="op">;</SPAN>
                    limit<SPAN class="op">--</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="rem">// if both first and last points are conic,</SPAN>
                    <SPAN class="rem">// start at their middle and record its position</SPAN>
                    <SPAN class="rem">// for closure</SPAN>
                    v_start<SPAN class="op">.</SPAN>x <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>v_start<SPAN class="op">.</SPAN>x <SPAN class="op">+</SPAN> v_last<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>
                    v_start<SPAN class="op">.</SPAN>y <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>v_start<SPAN class="op">.</SPAN>y <SPAN class="op">+</SPAN> v_last<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>

                    v_last <SPAN class="op">=</SPAN> v_start<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                point<SPAN class="op">--</SPAN><SPAN class="op">;</SPAN>
                tags<SPAN class="op">--</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            x1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_start<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            y1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_start<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN> y1 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y1<SPAN class="op">;</SPAN>
            mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x1<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            path<SPAN class="op">.</SPAN>move_to<SPAN class="op">(</SPAN>value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                         value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN>point <SPAN class="op">&lt;</SPAN> limit<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                point<SPAN class="op">++</SPAN><SPAN class="op">;</SPAN>
                tags<SPAN class="op">++</SPAN><SPAN class="op">;</SPAN>

                tag <SPAN class="op">=</SPAN> FT_CURVE_TAG<SPAN class="op">(</SPAN>tags<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN>tag<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">case</SPAN> FT_CURVE_TAG_ON:  <SPAN class="rem">// emit a single line_to</SPAN>
                    <SPAN class="op">{</SPAN>
                        x1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>point<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        y1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>point<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN> y1 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y1<SPAN class="op">;</SPAN>
                        mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x1<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        path<SPAN class="op">.</SPAN>line_to<SPAN class="op">(</SPAN>value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                     value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="rem">//path.line_to(conv(point-&gt;x), flip_y ? -conv(point-&gt;y) : conv(point-&gt;y));</SPAN>
                        <SPAN class="kw1">continue</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>

                    <SPAN class="kw1">case</SPAN> FT_CURVE_TAG_CONIC:  <SPAN class="rem">// consume conic arcs</SPAN>
                    <SPAN class="op">{</SPAN>
                        v_control<SPAN class="op">.</SPAN>x <SPAN class="op">=</SPAN> point<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                        v_control<SPAN class="op">.</SPAN>y <SPAN class="op">=</SPAN> point<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>y<SPAN class="op">;</SPAN>

                    Do_Conic:
                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>point <SPAN class="op">&lt;</SPAN> limit<SPAN class="op">)</SPAN>
                        <SPAN class="op">{</SPAN>
                            FT_Vector vec<SPAN class="op">;</SPAN>
                            FT_Vector v_middle<SPAN class="op">;</SPAN>

                            point<SPAN class="op">++</SPAN><SPAN class="op">;</SPAN>
                            tags<SPAN class="op">++</SPAN><SPAN class="op">;</SPAN>
                            tag <SPAN class="op">=</SPAN> FT_CURVE_TAG<SPAN class="op">(</SPAN>tags<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

                            vec<SPAN class="op">.</SPAN>x <SPAN class="op">=</SPAN> point<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                            vec<SPAN class="op">.</SPAN>y <SPAN class="op">=</SPAN> point<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>y<SPAN class="op">;</SPAN>

                            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>tag <SPAN class="op">==</SPAN> FT_CURVE_TAG_ON<SPAN class="op">)</SPAN>
                            <SPAN class="op">{</SPAN>
                                x1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_control<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                                y1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_control<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                                x2 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                                y2 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> y1 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y1<SPAN class="op">;</SPAN> y2 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y2<SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
                                mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x1<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                                mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x2<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                                path<SPAN class="op">.</SPAN><A href="../include/agg_curves.h.html#curve3">curve3</A><SPAN class="op">(</SPAN>value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                            value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                                            value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                            value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                                <SPAN class="kw1">continue</SPAN><SPAN class="op">;</SPAN>
                            <SPAN class="op">}</SPAN>

                            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>tag <SPAN class="op">!=</SPAN> FT_CURVE_TAG_CONIC<SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>

                            v_middle<SPAN class="op">.</SPAN>x <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>v_control<SPAN class="op">.</SPAN>x <SPAN class="op">+</SPAN> vec<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>
                            v_middle<SPAN class="op">.</SPAN>y <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>v_control<SPAN class="op">.</SPAN>y <SPAN class="op">+</SPAN> vec<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>

                            x1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_control<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            y1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_control<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            x2 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_middle<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            y2 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_middle<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> y1 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y1<SPAN class="op">;</SPAN> y2 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y2<SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
                            mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x1<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x2<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            path<SPAN class="op">.</SPAN><A href="../include/agg_curves.h.html#curve3">curve3</A><SPAN class="op">(</SPAN>value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                        value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                                        value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                        value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

                            <SPAN class="rem">//path.<A href="../include/agg_curves.h.html#curve3">curve3</A>(conv(v_control.x), </SPAN>
                            <SPAN class="rem">//            flip_y ? -conv(v_control.y) : conv(v_control.y), </SPAN>
                            <SPAN class="rem">//            conv(v_middle.x), </SPAN>
                            <SPAN class="rem">//            flip_y ? -conv(v_middle.y) : conv(v_middle.y));</SPAN>

                            v_control <SPAN class="op">=</SPAN> vec<SPAN class="op">;</SPAN>
                            <SPAN class="kw1">goto</SPAN> Do_Conic<SPAN class="op">;</SPAN>
                        <SPAN class="op">}</SPAN>

                        x1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_control<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        y1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_control<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        x2 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_start<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        y2 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_start<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> y1 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y1<SPAN class="op">;</SPAN> y2 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y2<SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
                        mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x1<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x2<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        path<SPAN class="op">.</SPAN><A href="../include/agg_curves.h.html#curve3">curve3</A><SPAN class="op">(</SPAN>value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                    value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                                    value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                    value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

                        <SPAN class="rem">//path.<A href="../include/agg_curves.h.html#curve3">curve3</A>(conv(v_control.x), </SPAN>
                        <SPAN class="rem">//            flip_y ? -conv(v_control.y) : conv(v_control.y), </SPAN>
                        <SPAN class="rem">//            conv(v_start.x), </SPAN>
                        <SPAN class="rem">//            flip_y ? -conv(v_start.y) : conv(v_start.y));</SPAN>
                        <SPAN class="kw1">goto</SPAN> Close<SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>

                    <SPAN class="kw1">default</SPAN>:  <SPAN class="rem">// FT_CURVE_TAG_CUBIC</SPAN>
                    <SPAN class="op">{</SPAN>
                        FT_Vector vec1<SPAN class="op">,</SPAN> vec2<SPAN class="op">;</SPAN>

                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>point <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN> <SPAN class="op">&gt;</SPAN> limit <SPAN class="op">||</SPAN> FT_CURVE_TAG<SPAN class="op">(</SPAN>tags<SPAN class="op">[</SPAN><SPAN class="num">1</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">!=</SPAN> FT_CURVE_TAG_CUBIC<SPAN class="op">)</SPAN>
                        <SPAN class="op">{</SPAN>
                            <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="op">}</SPAN>

                        vec1<SPAN class="op">.</SPAN>x <SPAN class="op">=</SPAN> point<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>x<SPAN class="op">;</SPAN> 
                        vec1<SPAN class="op">.</SPAN>y <SPAN class="op">=</SPAN> point<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>y<SPAN class="op">;</SPAN>
                        vec2<SPAN class="op">.</SPAN>x <SPAN class="op">=</SPAN> point<SPAN class="op">[</SPAN><SPAN class="num">1</SPAN><SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>x<SPAN class="op">;</SPAN> 
                        vec2<SPAN class="op">.</SPAN>y <SPAN class="op">=</SPAN> point<SPAN class="op">[</SPAN><SPAN class="num">1</SPAN><SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>y<SPAN class="op">;</SPAN>

                        point <SPAN class="op">+=</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>
                        tags  <SPAN class="op">+=</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>

                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>point <SPAN class="op">&lt;=</SPAN> limit<SPAN class="op">)</SPAN>
                        <SPAN class="op">{</SPAN>
                            FT_Vector vec<SPAN class="op">;</SPAN>

                            vec<SPAN class="op">.</SPAN>x <SPAN class="op">=</SPAN> point<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                            vec<SPAN class="op">.</SPAN>y <SPAN class="op">=</SPAN> point<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>y<SPAN class="op">;</SPAN>

                            x1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec1<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            y1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec1<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            x2 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec2<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            y2 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec2<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            x3 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            y3 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> y1 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y1<SPAN class="op">;</SPAN> y2 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y2<SPAN class="op">;</SPAN> y3 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y3<SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
                            mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x1<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x2<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x3<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y3<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            path<SPAN class="op">.</SPAN><A href="../include/agg_curves.h.html#curve4">curve4</A><SPAN class="op">(</SPAN>value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                        value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                                        value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                        value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                                        value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x3<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                        value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y3<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

                            <SPAN class="rem">//path.<A href="../include/agg_curves.h.html#curve4">curve4</A>(conv(vec1.x), </SPAN>
                            <SPAN class="rem">//            flip_y ? -conv(vec1.y) : conv(vec1.y), </SPAN>
                            <SPAN class="rem">//            conv(vec2.x), </SPAN>
                            <SPAN class="rem">//            flip_y ? -conv(vec2.y) : conv(vec2.y),</SPAN>
                            <SPAN class="rem">//            conv(vec.x), </SPAN>
                            <SPAN class="rem">//            flip_y ? -conv(vec.y) : conv(vec.y));</SPAN>
                            <SPAN class="kw1">continue</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="op">}</SPAN>

                        x1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec1<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        y1 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec1<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        x2 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec2<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        y2 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>vec2<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        x3 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_start<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        y3 <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>v_start<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> y1 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y1<SPAN class="op">;</SPAN> y2 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y2<SPAN class="op">;</SPAN> y3 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y3<SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
                        mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x1<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x2<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x3<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y3<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        path<SPAN class="op">.</SPAN><A href="../include/agg_curves.h.html#curve4">curve4</A><SPAN class="op">(</SPAN>value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                    value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                                    value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                    value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                                    value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x3<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                    value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y3<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

                        <SPAN class="rem">//path.<A href="../include/agg_curves.h.html#curve4">curve4</A>(conv(vec1.x), </SPAN>
                        <SPAN class="rem">//            flip_y ? -conv(vec1.y) : conv(vec1.y), </SPAN>
                        <SPAN class="rem">//            conv(vec2.x), </SPAN>
                        <SPAN class="rem">//            flip_y ? -conv(vec2.y) : conv(vec2.y),</SPAN>
                        <SPAN class="rem">//            conv(v_start.x), </SPAN>
                        <SPAN class="rem">//            flip_y ? -conv(v_start.y) : conv(v_start.y));</SPAN>
                        <SPAN class="kw1">goto</SPAN> Close<SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>

            path<SPAN class="op">.</SPAN>close_polygon<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

       Close:
            first <SPAN class="op">=</SPAN> last <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> 
        <SPAN class="op">}</SPAN>

        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> <SPAN class="kw1">class</SPAN> ScanlineStorage<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> decompose_ft_bitmap_mono<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> FT_Bitmap<SPAN class="op">&amp;</SPAN> bitmap<SPAN class="op">,</SPAN>
                                  <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> y<SPAN class="op">,</SPAN>
                                  <SPAN class="kw1">bool</SPAN> flip_y<SPAN class="op">,</SPAN>
                                  Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN>
                                  ScanlineStorage<SPAN class="op">&amp;</SPAN> storage<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">int</SPAN> i<SPAN class="op">;</SPAN>
        <SPAN class="kw1">const</SPAN> <A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN> buf <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN>bitmap<SPAN class="op">.</SPAN>buffer<SPAN class="op">;</SPAN>
        <SPAN class="kw1">int</SPAN> pitch <SPAN class="op">=</SPAN> bitmap<SPAN class="op">.</SPAN>pitch<SPAN class="op">;</SPAN>
        sl<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> x <SPAN class="op">+</SPAN> bitmap<SPAN class="op">.</SPAN>width<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        storage<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            buf <SPAN class="op">+=</SPAN> bitmap<SPAN class="op">.</SPAN>pitch <SPAN class="op">*</SPAN> <SPAN class="op">(</SPAN>bitmap<SPAN class="op">.</SPAN>rows <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            y <SPAN class="op">+=</SPAN> bitmap<SPAN class="op">.</SPAN>rows<SPAN class="op">;</SPAN>
            pitch <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>pitch<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> bitmap<SPAN class="op">.</SPAN>rows<SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            sl<SPAN class="op">.</SPAN>reset_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            bitset_iterator bits<SPAN class="op">(</SPAN>buf<SPAN class="op">,</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> j<SPAN class="op">;</SPAN>
            <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>j <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> j <SPAN class="op">&lt;</SPAN> bitmap<SPAN class="op">.</SPAN>width<SPAN class="op">;</SPAN> j<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>bits<SPAN class="op">.</SPAN>bit<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x <SPAN class="op">+</SPAN> j<SPAN class="op">,</SPAN> <A href="../include/agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">++</SPAN>bits<SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            buf <SPAN class="op">+=</SPAN> pitch<SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>sl<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                sl<SPAN class="op">.</SPAN>finalize<SPAN class="op">(</SPAN>y <SPAN class="op">-</SPAN> i <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                storage<SPAN class="op">.</SPAN>render<SPAN class="op">(</SPAN>sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Rasterizer<SPAN class="op">,</SPAN> <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> <SPAN class="kw1">class</SPAN> ScanlineStorage<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> decompose_ft_bitmap_gray8<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> FT_Bitmap<SPAN class="op">&amp;</SPAN> bitmap<SPAN class="op">,</SPAN>
                                   <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> y<SPAN class="op">,</SPAN>
                                   <SPAN class="kw1">bool</SPAN> flip_y<SPAN class="op">,</SPAN>
                                   Rasterizer<SPAN class="op">&amp;</SPAN> ras<SPAN class="op">,</SPAN>
                                   Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN>
                                   ScanlineStorage<SPAN class="op">&amp;</SPAN> storage<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">int</SPAN> i<SPAN class="op">,</SPAN> j<SPAN class="op">;</SPAN>
        <SPAN class="kw1">const</SPAN> <A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN> buf <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN>bitmap<SPAN class="op">.</SPAN>buffer<SPAN class="op">;</SPAN>
        <SPAN class="kw1">int</SPAN> pitch <SPAN class="op">=</SPAN> bitmap<SPAN class="op">.</SPAN>pitch<SPAN class="op">;</SPAN>
        sl<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> x <SPAN class="op">+</SPAN> bitmap<SPAN class="op">.</SPAN>width<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        storage<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            buf <SPAN class="op">+=</SPAN> bitmap<SPAN class="op">.</SPAN>pitch <SPAN class="op">*</SPAN> <SPAN class="op">(</SPAN>bitmap<SPAN class="op">.</SPAN>rows <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            y <SPAN class="op">+=</SPAN> bitmap<SPAN class="op">.</SPAN>rows<SPAN class="op">;</SPAN>
            pitch <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>pitch<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> bitmap<SPAN class="op">.</SPAN>rows<SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            sl<SPAN class="op">.</SPAN>reset_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> <A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN> p <SPAN class="op">=</SPAN> buf<SPAN class="op">;</SPAN>
            <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>j <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> j <SPAN class="op">&lt;</SPAN> bitmap<SPAN class="op">.</SPAN>width<SPAN class="op">;</SPAN> j<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">*</SPAN>p<SPAN class="op">)</SPAN> sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x <SPAN class="op">+</SPAN> j<SPAN class="op">,</SPAN> ras<SPAN class="op">.</SPAN>apply_gamma<SPAN class="op">(</SPAN><SPAN class="op">*</SPAN>p<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">++</SPAN>p<SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            buf <SPAN class="op">+=</SPAN> pitch<SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>sl<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                sl<SPAN class="op">.</SPAN>finalize<SPAN class="op">(</SPAN>y <SPAN class="op">-</SPAN> i <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                storage<SPAN class="op">.</SPAN>render<SPAN class="op">(</SPAN>sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>













    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <A href="agg_font_freetype.h.html#font_engine_freetype_base">font_engine_freetype_base</A>::~<A href="agg_font_freetype.h.html#font_engine_freetype_base">font_engine_freetype_base</A><SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">;</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> m_num_faces<SPAN class="op">;</SPAN> <SPAN class="op">++</SPAN>i<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_face_names<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
            FT_Done_Face<SPAN class="op">(</SPAN>m_faces<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_face_names<SPAN class="op">;</SPAN>
        <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_faces<SPAN class="op">;</SPAN>
        <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_signature<SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_library_initialized<SPAN class="op">)</SPAN> FT_Done_FreeType<SPAN class="op">(</SPAN>m_library<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    font_engine_freetype_base::<A href="agg_font_freetype.h.html#font_engine_freetype_base">font_engine_freetype_base</A><SPAN class="op">(</SPAN><SPAN class="kw1">bool</SPAN> flag32<SPAN class="op">,</SPAN> 
                                                         <SPAN class="kw1">unsigned</SPAN> max_faces<SPAN class="op">)</SPAN> :
        m_flag32<SPAN class="op">(</SPAN>flag32<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_change_stamp<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_last_error<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_name<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_name_len<SPAN class="op">(</SPAN><SPAN class="num">256</SPAN><SPAN class="op">-</SPAN><SPAN class="num">16</SPAN><SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_face_index<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_char_map<SPAN class="op">(</SPAN>FT_ENCODING_NONE<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_signature<SPAN class="op">(</SPAN><SPAN class="kw1">new</SPAN> <SPAN class="kw1">char</SPAN> <SPAN class="op">[</SPAN><SPAN class="num">256</SPAN><SPAN class="op">+</SPAN><SPAN class="num">256</SPAN><SPAN class="op">-</SPAN><SPAN class="num">16</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_height<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_width<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_hinting<SPAN class="op">(</SPAN><SPAN class="kw1">true</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_flip_y<SPAN class="op">(</SPAN><SPAN class="kw1">false</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_library_initialized<SPAN class="op">(</SPAN><SPAN class="kw1">false</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_library<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_faces<SPAN class="op">(</SPAN><SPAN class="kw1">new</SPAN> FT_Face <SPAN class="op">[</SPAN>max_faces<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_face_names<SPAN class="op">(</SPAN><SPAN class="kw1">new</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> <SPAN class="op">[</SPAN>max_faces<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_num_faces<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_max_faces<SPAN class="op">(</SPAN>max_faces<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_cur_face<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_resolution<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_glyph_rendering<SPAN class="op">(</SPAN>glyph_ren_native_gray8<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_glyph_index<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_data_size<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_data_type<SPAN class="op">(</SPAN>glyph_data_invalid<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_bounds<SPAN class="op">(</SPAN><SPAN class="num">1</SPAN><SPAN class="op">,</SPAN><SPAN class="num">1</SPAN><SPAN class="op">,</SPAN><SPAN class="num">0</SPAN><SPAN class="op">,</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_advance_x<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_advance_y<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>

        m_path16<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_path32<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_curves16<SPAN class="op">(</SPAN>m_path16<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_curves32<SPAN class="op">(</SPAN>m_path32<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_scanline_aa<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_scanline_bin<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_scanlines_aa<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_scanlines_bin<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_rasterizer<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        m_curves16<SPAN class="op">.</SPAN>approximation_scale<SPAN class="op">(</SPAN><SPAN class="num">4</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        m_curves32<SPAN class="op">.</SPAN>approximation_scale<SPAN class="op">(</SPAN><SPAN class="num">4</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        m_last_error <SPAN class="op">=</SPAN> FT_Init_FreeType<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>m_library<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_last_error <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> m_library_initialized <SPAN class="op">=</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">void</SPAN> font_engine_freetype_base::resolution<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> dpi<SPAN class="op">)</SPAN> 
    <SPAN class="op">{</SPAN> 
        m_resolution <SPAN class="op">=</SPAN> dpi<SPAN class="op">;</SPAN>
        update_char_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">int</SPAN> font_engine_freetype_base::find_face<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> face_name<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">;</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> m_num_faces<SPAN class="op">;</SPAN> <SPAN class="op">++</SPAN>i<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>strcmp<SPAN class="op">(</SPAN>face_name<SPAN class="op">,</SPAN> m_face_names<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN> i<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">double</SPAN> font_engine_freetype_base::ascender<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">return</SPAN> m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>ascender <SPAN class="op">*</SPAN> height<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>height<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">double</SPAN> font_engine_freetype_base::descender<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">return</SPAN> m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>descender <SPAN class="op">*</SPAN> height<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>height<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">bool</SPAN> font_engine_freetype_base::load_font<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> font_name<SPAN class="op">,</SPAN> 
                                              <SPAN class="kw1">unsigned</SPAN> face_index<SPAN class="op">,</SPAN>
                                              glyph_rendering ren_type<SPAN class="op">,</SPAN>
                                              <SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> font_mem<SPAN class="op">,</SPAN> 
                                              <SPAN class="kw1">const</SPAN> <SPAN class="kw1">long</SPAN> font_mem_size<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">bool</SPAN> ret <SPAN class="op">=</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_library_initialized<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            m_last_error <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">int</SPAN> idx <SPAN class="op">=</SPAN> find_face<SPAN class="op">(</SPAN>font_name<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>idx <SPAN class="op">&gt;=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                m_cur_face <SPAN class="op">=</SPAN> m_faces<SPAN class="op">[</SPAN>idx<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                m_name     <SPAN class="op">=</SPAN> m_face_names<SPAN class="op">[</SPAN>idx<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="kw1">else</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_num_faces <SPAN class="op">&gt;=</SPAN> m_max_faces<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_face_names<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                    FT_Done_Face<SPAN class="op">(</SPAN>m_faces<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    memcpy<SPAN class="op">(</SPAN>m_faces<SPAN class="op">,</SPAN> 
                           m_faces <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN> 
                           <SPAN class="op">(</SPAN>m_max_faces <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> <SPAN class="kw1">sizeof</SPAN><SPAN class="op">(</SPAN>FT_Face<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    memcpy<SPAN class="op">(</SPAN>m_face_names<SPAN class="op">,</SPAN> 
                           m_face_names <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN> 
                           <SPAN class="op">(</SPAN>m_max_faces <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> <SPAN class="kw1">sizeof</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_num_faces <SPAN class="op">=</SPAN> m_max_faces <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>

                <SPAN class="kw1">if</SPAN> <SPAN class="op">(</SPAN>font_mem <SPAN class="op">&amp;&amp;</SPAN> font_mem_size<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    m_last_error <SPAN class="op">=</SPAN> FT_New_Memory_Face<SPAN class="op">(</SPAN>m_library<SPAN class="op">,</SPAN> 
                                                      <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> FT_Byte<SPAN class="op">*</SPAN><SPAN class="op">)</SPAN>font_mem<SPAN class="op">,</SPAN> 
                                                      font_mem_size<SPAN class="op">,</SPAN> 
                                                      face_index<SPAN class="op">,</SPAN> 
                                                      <SPAN class="op">&amp;</SPAN>m_faces<SPAN class="op">[</SPAN>m_num_faces<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    m_last_error <SPAN class="op">=</SPAN> FT_New_Face<SPAN class="op">(</SPAN>m_library<SPAN class="op">,</SPAN>
                                               font_name<SPAN class="op">,</SPAN>
                                               face_index<SPAN class="op">,</SPAN>
                                               <SPAN class="op">&amp;</SPAN>m_faces<SPAN class="op">[</SPAN>m_num_faces<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>

                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_last_error <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    m_face_names<SPAN class="op">[</SPAN>m_num_faces<SPAN class="op">]</SPAN> <SPAN class="op">=</SPAN> <SPAN class="kw1">new</SPAN> <SPAN class="kw1">char</SPAN> <SPAN class="op">[</SPAN>strlen<SPAN class="op">(</SPAN>font_name<SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                    strcpy<SPAN class="op">(</SPAN>m_face_names<SPAN class="op">[</SPAN>m_num_faces<SPAN class="op">]</SPAN><SPAN class="op">,</SPAN> font_name<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_cur_face <SPAN class="op">=</SPAN> m_faces<SPAN class="op">[</SPAN>m_num_faces<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                    m_name     <SPAN class="op">=</SPAN> m_face_names<SPAN class="op">[</SPAN>m_num_faces<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">++</SPAN>m_num_faces<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    m_face_names<SPAN class="op">[</SPAN>m_num_faces<SPAN class="op">]</SPAN> <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
                    m_cur_face <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
                    m_name <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>


            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_last_error <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                ret <SPAN class="op">=</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                
                <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN>ren_type<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                <SPAN class="kw1">case</SPAN> glyph_ren_native_mono:
                    m_glyph_rendering <SPAN class="op">=</SPAN> glyph_ren_native_mono<SPAN class="op">;</SPAN>
                    <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

                <SPAN class="kw1">case</SPAN> glyph_ren_native_gray8:
                    m_glyph_rendering <SPAN class="op">=</SPAN> glyph_ren_native_gray8<SPAN class="op">;</SPAN>
                    <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

                <SPAN class="kw1">case</SPAN> glyph_ren_outline:
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>FT_IS_SCALABLE<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_glyph_rendering <SPAN class="op">=</SPAN> glyph_ren_outline<SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">else</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_glyph_rendering <SPAN class="op">=</SPAN> glyph_ren_native_gray8<SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

                <SPAN class="kw1">case</SPAN> glyph_ren_agg_mono:
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>FT_IS_SCALABLE<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_glyph_rendering <SPAN class="op">=</SPAN> glyph_ren_agg_mono<SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">else</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_glyph_rendering <SPAN class="op">=</SPAN> glyph_ren_native_mono<SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

                <SPAN class="kw1">case</SPAN> glyph_ren_agg_gray8:
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>FT_IS_SCALABLE<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_glyph_rendering <SPAN class="op">=</SPAN> glyph_ren_agg_gray8<SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">else</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_glyph_rendering <SPAN class="op">=</SPAN> glyph_ren_native_gray8<SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                update_signature<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> ret<SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">bool</SPAN> font_engine_freetype_base::attach<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> file_name<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            m_last_error <SPAN class="op">=</SPAN> FT_Attach_File<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">,</SPAN> file_name<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">return</SPAN> m_last_error <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">unsigned</SPAN> font_engine_freetype_base::num_faces<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">return</SPAN> m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>num_faces<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">bool</SPAN> font_engine_freetype_base::char_map<SPAN class="op">(</SPAN>FT_Encoding char_map<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            m_last_error <SPAN class="op">=</SPAN> FT_Select_Charmap<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">,</SPAN> m_char_map<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_last_error <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                update_signature<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">bool</SPAN> font_engine_freetype_base::height<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> h<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        m_height <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>h <SPAN class="op">*</SPAN> <SPAN class="num">64</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            update_char_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">bool</SPAN> font_engine_freetype_base::width<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> w<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        m_width <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>w <SPAN class="op">*</SPAN> <SPAN class="num">64</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            update_char_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">void</SPAN> font_engine_freetype_base::hinting<SPAN class="op">(</SPAN><SPAN class="kw1">bool</SPAN> h<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN> 
        m_hinting <SPAN class="op">=</SPAN> h<SPAN class="op">;</SPAN> 
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            update_signature<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">void</SPAN> font_engine_freetype_base::flip_y<SPAN class="op">(</SPAN><SPAN class="kw1">bool</SPAN> f<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN> 
        m_flip_y <SPAN class="op">=</SPAN> f<SPAN class="op">;</SPAN> 
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            update_signature<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">void</SPAN> font_engine_freetype_base::transform<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <A href="../include/agg_trans_affine.h.html#trans_affine">trans_affine</A><SPAN class="op">&amp;</SPAN> affine<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        m_affine <SPAN class="op">=</SPAN> affine<SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            update_signature<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">void</SPAN> font_engine_freetype_base::update_signature<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face <SPAN class="op">&amp;&amp;</SPAN> m_name<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">unsigned</SPAN> name_len <SPAN class="op">=</SPAN> strlen<SPAN class="op">(</SPAN>m_name<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>name_len <SPAN class="op">&gt;</SPAN> m_name_len<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_signature<SPAN class="op">;</SPAN>
                m_signature <SPAN class="op">=</SPAN> <SPAN class="kw1">new</SPAN> <SPAN class="kw1">char</SPAN> <SPAN class="op">[</SPAN>name_len <SPAN class="op">+</SPAN> <SPAN class="num">32</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">256</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                m_name_len <SPAN class="op">=</SPAN> name_len <SPAN class="op">+</SPAN> <SPAN class="num">32</SPAN> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            <SPAN class="kw1">unsigned</SPAN> gamma_hash <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_native_gray8 <SPAN class="op">||</SPAN>
               m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_mono <SPAN class="op">||</SPAN> 
               m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_gray8<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">unsigned</SPAN> <SPAN class="kw1">char</SPAN> gamma_table<SPAN class="op">[</SPAN><A href="../include/agg_rasterizer_scanline_aa.h.html#rasterizer_scanline_aa">rasterizer_scanline_aa</A><SPAN class="op">&lt;</SPAN><SPAN class="op">&gt;</SPAN>::aa_scale<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">;</SPAN>
                <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> <A href="../include/agg_rasterizer_scanline_aa.h.html#rasterizer_scanline_aa">rasterizer_scanline_aa</A><SPAN class="op">&lt;</SPAN><SPAN class="op">&gt;</SPAN>::aa_scale<SPAN class="op">;</SPAN> <SPAN class="op">++</SPAN>i<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    gamma_table<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN> <SPAN class="op">=</SPAN> m_rasterizer<SPAN class="op">.</SPAN>apply_gamma<SPAN class="op">(</SPAN>i<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                gamma_hash <SPAN class="op">=</SPAN> calc_crc32<SPAN class="op">(</SPAN>gamma_table<SPAN class="op">,</SPAN> <SPAN class="kw1">sizeof</SPAN><SPAN class="op">(</SPAN>gamma_table<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            sprintf<SPAN class="op">(</SPAN>m_signature<SPAN class="op">,</SPAN> 
                    <SPAN class="str">&quot;%s,%u,%d,%d,%d:%dx%d,%d,%d,%08X&quot;</SPAN><SPAN class="op">,</SPAN> 
                    m_name<SPAN class="op">,</SPAN>
                    m_char_map<SPAN class="op">,</SPAN>
                    m_face_index<SPAN class="op">,</SPAN>
                    <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>m_glyph_rendering<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                    m_resolution<SPAN class="op">,</SPAN>
                    m_height<SPAN class="op">,</SPAN>
                    m_width<SPAN class="op">,</SPAN>
                    <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>m_hinting<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                    <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>m_flip_y<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                    gamma_hash<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_outline <SPAN class="op">||</SPAN>
               m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_mono <SPAN class="op">||</SPAN>
               m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_gray8<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">double</SPAN> mtx<SPAN class="op">[</SPAN><SPAN class="num">6</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">char</SPAN> buf<SPAN class="op">[</SPAN><SPAN class="num">100</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                m_affine<SPAN class="op">.</SPAN>store_to<SPAN class="op">(</SPAN>mtx<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                sprintf<SPAN class="op">(</SPAN>buf<SPAN class="op">,</SPAN> <SPAN class="str">&quot;,%08X%08X%08X%08X%08X%08X&quot;</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">1</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">2</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">3</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">4</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">5</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                strcat<SPAN class="op">(</SPAN>m_signature<SPAN class="op">,</SPAN> buf<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="op">++</SPAN>m_change_stamp<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">void</SPAN> font_engine_freetype_base::update_char_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_resolution<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                FT_Set_Char_Size<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">,</SPAN> 
                                 m_width<SPAN class="op">,</SPAN>       <SPAN class="rem">// char_width in 1/64th of points</SPAN>
                                 m_height<SPAN class="op">,</SPAN>      <SPAN class="rem">// char_height in 1/64th of points</SPAN>
                                 m_resolution<SPAN class="op">,</SPAN>  <SPAN class="rem">// horizontal device resolution </SPAN>
                                 m_resolution<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="rem">// vertical device resolution </SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="kw1">else</SPAN>
            <SPAN class="op">{</SPAN>
                FT_Set_Pixel_Sizes<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">,</SPAN>    
                                   m_width <SPAN class="op">&gt;&gt;</SPAN> <SPAN class="num">6</SPAN><SPAN class="op">,</SPAN>    <SPAN class="rem">// pixel_width</SPAN>
                                   m_height <SPAN class="op">&gt;&gt;</SPAN> <SPAN class="num">6</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>  <SPAN class="rem">// pixel_height</SPAN>
            <SPAN class="op">}</SPAN>
            update_signature<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>





    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">bool</SPAN> font_engine_freetype_base::prepare_glyph<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> glyph_code<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        m_glyph_index <SPAN class="op">=</SPAN> FT_Get_Char_Index<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">,</SPAN> glyph_code<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        m_last_error <SPAN class="op">=</SPAN> FT_Load_Glyph<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">,</SPAN> 
                                     m_glyph_index<SPAN class="op">,</SPAN> 
                                     m_hinting ? FT_LOAD_DEFAULT : FT_LOAD_NO_HINTING<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
<SPAN class="rem">//                                     m_hinting ? FT_LOAD_FORCE_AUTOHINT : FT_LOAD_NO_HINTING);</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_last_error <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN>m_glyph_rendering<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
            <SPAN class="kw1">case</SPAN> glyph_ren_native_mono:
                m_last_error <SPAN class="op">=</SPAN> FT_Render_Glyph<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">,</SPAN> FT_RENDER_MODE_MONO<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_last_error <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    decompose_ft_bitmap_mono<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>bitmap<SPAN class="op">,</SPAN> 
                                             m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>bitmap_left<SPAN class="op">,</SPAN>
                                             m_flip_y ? <SPAN class="op">-</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>bitmap_top : 
                                                         m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>bitmap_top<SPAN class="op">,</SPAN>
                                             m_flip_y<SPAN class="op">,</SPAN>
                                             m_scanline_bin<SPAN class="op">,</SPAN>
                                             m_scanlines_bin<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                    m_data_size <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> 
                    m_data_type <SPAN class="op">=</SPAN> glyph_data_mono<SPAN class="op">;</SPAN>
                    m_advance_x <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_advance_y <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>


            <SPAN class="kw1">case</SPAN> glyph_ren_native_gray8:
                m_last_error <SPAN class="op">=</SPAN> FT_Render_Glyph<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">,</SPAN> FT_RENDER_MODE_NORMAL<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_last_error <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    decompose_ft_bitmap_gray8<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>bitmap<SPAN class="op">,</SPAN> 
                                              m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>bitmap_left<SPAN class="op">,</SPAN>
                                              m_flip_y ? <SPAN class="op">-</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>bitmap_top : 
                                                          m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>bitmap_top<SPAN class="op">,</SPAN>
                                              m_flip_y<SPAN class="op">,</SPAN>
                                              m_rasterizer<SPAN class="op">,</SPAN>
                                              m_scanline_aa<SPAN class="op">,</SPAN>
                                              m_scanlines_aa<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                    m_data_size <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> 
                    m_data_type <SPAN class="op">=</SPAN> glyph_data_gray8<SPAN class="op">;</SPAN>
                    m_advance_x <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_advance_y <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>


            <SPAN class="kw1">case</SPAN> glyph_ren_outline:
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_last_error <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_flag32<SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_path32<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>decompose_ft_outline<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>outline<SPAN class="op">,</SPAN>
                                                m_flip_y<SPAN class="op">,</SPAN> 
                                                m_affine<SPAN class="op">,</SPAN>
                                                m_path32<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                        <SPAN class="op">{</SPAN>
                            <A href="../include/agg_basics.h.html#rect_d">rect_d</A> bnd  <SPAN class="op">=</SPAN> m_path32<SPAN class="op">.</SPAN><A href="../include/agg_bounding_rect.h.html#bounding_rect">bounding_rect</A><SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_data_size <SPAN class="op">=</SPAN> m_path32<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_data_type <SPAN class="op">=</SPAN> glyph_data_outline<SPAN class="op">;</SPAN>
                            m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>floor<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>x1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>floor<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>ceil<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>ceil<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_advance_x <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_advance_y <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_affine<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>m_advance_x<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>m_advance_y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="op">}</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">else</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_path16<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>decompose_ft_outline<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>outline<SPAN class="op">,</SPAN>
                                                m_flip_y<SPAN class="op">,</SPAN> 
                                                m_affine<SPAN class="op">,</SPAN>
                                                m_path16<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                        <SPAN class="op">{</SPAN>
                            <A href="../include/agg_basics.h.html#rect_d">rect_d</A> bnd  <SPAN class="op">=</SPAN> m_path16<SPAN class="op">.</SPAN><A href="../include/agg_bounding_rect.h.html#bounding_rect">bounding_rect</A><SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_data_size <SPAN class="op">=</SPAN> m_path16<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_data_type <SPAN class="op">=</SPAN> glyph_data_outline<SPAN class="op">;</SPAN>
                            m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>floor<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>x1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>floor<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>ceil<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>ceil<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_advance_x <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_advance_y <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            m_affine<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>m_advance_x<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>m_advance_y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                            <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="op">}</SPAN>
                    <SPAN class="op">}</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> glyph_ren_agg_mono:
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_last_error <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    m_rasterizer<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_flag32<SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_path32<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        decompose_ft_outline<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>outline<SPAN class="op">,</SPAN>
                                             m_flip_y<SPAN class="op">,</SPAN> 
                                             m_affine<SPAN class="op">,</SPAN>
                                             m_path32<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_rasterizer<SPAN class="op">.</SPAN>add_path<SPAN class="op">(</SPAN>m_curves32<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">else</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_path16<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        decompose_ft_outline<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>outline<SPAN class="op">,</SPAN>
                                             m_flip_y<SPAN class="op">,</SPAN> 
                                             m_affine<SPAN class="op">,</SPAN>
                                             m_path16<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_rasterizer<SPAN class="op">.</SPAN>add_path<SPAN class="op">(</SPAN>m_curves16<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    m_scanlines_bin<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="rem">// Remove all </SPAN>
                    <A href="../include/agg_renderer_scanline.h.html#render_scanlines">render_scanlines</A><SPAN class="op">(</SPAN>m_rasterizer<SPAN class="op">,</SPAN> m_scanline_bin<SPAN class="op">,</SPAN> m_scanlines_bin<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                    m_data_size <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> 
                    m_data_type <SPAN class="op">=</SPAN> glyph_data_mono<SPAN class="op">;</SPAN>
                    m_advance_x <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_advance_y <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_affine<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>m_advance_x<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>m_advance_y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>


            <SPAN class="kw1">case</SPAN> glyph_ren_agg_gray8:
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_last_error <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    m_rasterizer<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_flag32<SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_path32<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        decompose_ft_outline<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>outline<SPAN class="op">,</SPAN>
                                             m_flip_y<SPAN class="op">,</SPAN> 
                                             m_affine<SPAN class="op">,</SPAN>
                                             m_path32<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_rasterizer<SPAN class="op">.</SPAN>add_path<SPAN class="op">(</SPAN>m_curves32<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">else</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_path16<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        decompose_ft_outline<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>outline<SPAN class="op">,</SPAN>
                                             m_flip_y<SPAN class="op">,</SPAN> 
                                             m_affine<SPAN class="op">,</SPAN>
                                             m_path16<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_rasterizer<SPAN class="op">.</SPAN>add_path<SPAN class="op">(</SPAN>m_curves16<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    m_scanlines_aa<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="rem">// Remove all </SPAN>
                    <A href="../include/agg_renderer_scanline.h.html#render_scanlines">render_scanlines</A><SPAN class="op">(</SPAN>m_rasterizer<SPAN class="op">,</SPAN> m_scanline_aa<SPAN class="op">,</SPAN> m_scanlines_aa<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                    m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                    m_data_size <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> 
                    m_data_type <SPAN class="op">=</SPAN> glyph_data_gray8<SPAN class="op">;</SPAN>
                    m_advance_x <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_advance_y <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>glyph<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>advance<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_affine<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>m_advance_x<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>m_advance_y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>




    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">void</SPAN> font_engine_freetype_base::write_glyph_to<SPAN class="op">(</SPAN><A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN> data<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>data <SPAN class="op">&amp;&amp;</SPAN> m_data_size<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN>m_data_type<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
            <SPAN class="kw1">default</SPAN>: <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">case</SPAN> glyph_data_mono:    m_scanlines_bin<SPAN class="op">.</SPAN>serialize<SPAN class="op">(</SPAN>data<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">case</SPAN> glyph_data_gray8:   m_scanlines_aa<SPAN class="op">.</SPAN>serialize<SPAN class="op">(</SPAN>data<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>  <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">case</SPAN> glyph_data_outline: 
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_flag32<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    m_path32<SPAN class="op">.</SPAN>serialize<SPAN class="op">(</SPAN>data<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    m_path16<SPAN class="op">.</SPAN>serialize<SPAN class="op">(</SPAN>data<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">case</SPAN> glyph_data_invalid: <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">bool</SPAN> font_engine_freetype_base::add_kerning<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> first<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> second<SPAN class="op">,</SPAN>
                                           <SPAN class="kw1">double</SPAN><SPAN class="op">*</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN><SPAN class="op">*</SPAN> y<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_face <SPAN class="op">&amp;&amp;</SPAN> first <SPAN class="op">&amp;&amp;</SPAN> second <SPAN class="op">&amp;&amp;</SPAN> FT_HAS_KERNING<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            FT_Vector delta<SPAN class="op">;</SPAN>
            FT_Get_Kerning<SPAN class="op">(</SPAN>m_cur_face<SPAN class="op">,</SPAN> first<SPAN class="op">,</SPAN> second<SPAN class="op">,</SPAN>
                           FT_KERNING_DEFAULT<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>delta<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">double</SPAN> dx <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>delta<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">double</SPAN> dy <SPAN class="op">=</SPAN> int26p6_to_dbl<SPAN class="op">(</SPAN>delta<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_outline <SPAN class="op">||</SPAN>
               m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_mono <SPAN class="op">||</SPAN>
               m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_gray8<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                m_affine<SPAN class="op">.</SPAN>transform_2x2<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>dx<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>dy<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="op">*</SPAN>x <SPAN class="op">+=</SPAN> dx<SPAN class="op">;</SPAN>
            <SPAN class="op">*</SPAN>y <SPAN class="op">+=</SPAN> dy<SPAN class="op">;</SPAN>

            <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>



<SPAN class="op">}</SPAN>


</PRE></TD></TR></TABLE><FONT style="margin-left:1em"><I></I></FONT><TABLE width="640px" bgcolor="#583927" height="1px" border="0" cellspacing="0" cellpadding="0" style="margin:0px;"><TR><TD></TD></TR></TABLE>
<TABLE width="640px" border="0" cellspacing="0" cellpadding="0">
<TR><TD><CENTER><SPAN class="authors">
Copyright <SPAN class="larger">&#169;</SPAN> 2002-2006
<A href="../../mcseem/index.html"><B>Maxim Shemanarev</B></A>
</SPAN></CENTER></TD></TR>
<TR><TD><CENTER><SPAN class="authors">
Web Design and Programming
<A href="../../mcseem/index.html"><B>Maxim Shemanarev</B></A>
</SPAN></CENTER></TD></TR>
</TABLE>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
</HTML>
