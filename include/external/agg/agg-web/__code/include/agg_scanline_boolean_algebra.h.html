<HTML><HEAD><TITLE>Anti-Grain Geometry - </TITLE>
<META http-equiv="Content-Type" content="text/html"/>
<LINK rel="stylesheet" type="text/css" href="../../agg.styles.css"/>
</HEAD>
<TABLE width="640px" border="0" cellspacing="0" cellpadding="0"><TR><TD><PRE><SPAN class="rem">//----------------------------------------------------------------------------</SPAN>
<SPAN class="rem">// Anti-Grain Geometry (AGG) - Version 2.5</SPAN>
<SPAN class="rem">// A high quality rendering engine for C++</SPAN>
<SPAN class="rem">// Copyright (C) 2002-2006 Maxim Shemanarev</SPAN>
<SPAN class="rem">// Contact: mcseem@antigrain.com</SPAN>
<SPAN class="rem">//          mcseemagg@yahoo.com</SPAN>
<SPAN class="rem">//          http://antigrain.com</SPAN>
<SPAN class="rem">// </SPAN>
<SPAN class="rem">// AGG is free software; you can redistribute it and/or</SPAN>
<SPAN class="rem">// modify it under the terms of the GNU General Public License</SPAN>
<SPAN class="rem">// as published by the Free Software Foundation; either version 2</SPAN>
<SPAN class="rem">// of the License, or (at your option) any later version.</SPAN>
<SPAN class="rem">// </SPAN>
<SPAN class="rem">// AGG is distributed in the hope that it will be useful,</SPAN>
<SPAN class="rem">// but WITHOUT ANY WARRANTY; without even the implied warranty of</SPAN>
<SPAN class="rem">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</SPAN>
<SPAN class="rem">// GNU General Public License for more details.</SPAN>
<SPAN class="rem">// </SPAN>
<SPAN class="rem">// You should have received a copy of the GNU General Public License</SPAN>
<SPAN class="rem">// along with AGG; if not, write to the Free Software</SPAN>
<SPAN class="rem">// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, </SPAN>
<SPAN class="rem">// MA 02110-1301, USA.</SPAN>
<SPAN class="rem">//----------------------------------------------------------------------------</SPAN>

<SPAN class="kw2">#ifndef</SPAN> AGG_SCANLINE_BOOLEAN_ALGEBRA_INCLUDED
<SPAN class="kw2">#define</SPAN> AGG_SCANLINE_BOOLEAN_ALGEBRA_INCLUDED

<SPAN class="kw2">#include</SPAN> <SPAN class="op">&lt;</SPAN>stdlib<SPAN class="op">.</SPAN>h<SPAN class="op">&gt;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="op">&lt;</SPAN>math<SPAN class="op">.</SPAN>h<SPAN class="op">&gt;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="agg_basics.h.html">agg_basics.h</A>&quot;</SPAN>


<SPAN class="kw1">namespace</SPAN> agg
<SPAN class="op">{</SPAN>

    <SPAN class="rem">//-----------------------------------------------<A name="sbool_combine_spans_bin"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_combine_spans_bin">sbool_combine_spans_bin</A></SPAN>
    <SPAN class="rem">// Functor.</SPAN>
    <SPAN class="rem">// Combine two binary encoded spans, i.e., when we don&#039;t have any</SPAN>
    <SPAN class="rem">// anti-aliasing information, but only X and Length. The function</SPAN>
    <SPAN class="rem">// is compatible with any type of scanlines.</SPAN>
    <SPAN class="rem">//----------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">&gt;</SPAN> 
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_combine_spans_bin">sbool_combine_spans_bin</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">void</SPAN> <SPAN class="kw1">operator</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator<SPAN class="op">&amp;</SPAN><SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline2::const_iterator<SPAN class="op">&amp;</SPAN><SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> len<SPAN class="op">,</SPAN> 
                          Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
        <SPAN class="op">{</SPAN>
            sl<SPAN class="op">.</SPAN>add_span<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>



    <SPAN class="rem">//---------------------------------------------<A name="sbool_combine_spans_empty"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_combine_spans_empty">sbool_combine_spans_empty</A></SPAN>
    <SPAN class="rem">// Functor.</SPAN>
    <SPAN class="rem">// Combine two spans as empty ones. The functor does nothing</SPAN>
    <SPAN class="rem">// and is used to XOR binary spans.</SPAN>
    <SPAN class="rem">//----------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">&gt;</SPAN> 
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_combine_spans_empty">sbool_combine_spans_empty</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">void</SPAN> <SPAN class="kw1">operator</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator<SPAN class="op">&amp;</SPAN><SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline2::const_iterator<SPAN class="op">&amp;</SPAN><SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">int</SPAN><SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN><SPAN class="op">,</SPAN> 
                          Scanline<SPAN class="op">&amp;</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
        <SPAN class="op">{</SPAN><SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>



    <SPAN class="rem">//--------------------------------------------------<A name="sbool_add_span_empty"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_empty">sbool_add_span_empty</A></SPAN>
    <SPAN class="rem">// Functor.</SPAN>
    <SPAN class="rem">// Add nothing. Used in conbine_shapes_sub</SPAN>
    <SPAN class="rem">//----------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">&gt;</SPAN> 
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_empty">sbool_add_span_empty</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">void</SPAN> <SPAN class="kw1">operator</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator<SPAN class="op">&amp;</SPAN><SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">int</SPAN><SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN><SPAN class="op">,</SPAN> 
                          Scanline<SPAN class="op">&amp;</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
        <SPAN class="op">{</SPAN><SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>


    <SPAN class="rem">//----------------------------------------------------<A name="sbool_add_span_bin"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_bin">sbool_add_span_bin</A></SPAN>
    <SPAN class="rem">// Functor.</SPAN>
    <SPAN class="rem">// Add a binary span</SPAN>
    <SPAN class="rem">//----------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">&gt;</SPAN> 
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_bin">sbool_add_span_bin</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">void</SPAN> <SPAN class="kw1">operator</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator<SPAN class="op">&amp;</SPAN><SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> len<SPAN class="op">,</SPAN> 
                          Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
        <SPAN class="op">{</SPAN>
            sl<SPAN class="op">.</SPAN>add_span<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>

    


    <SPAN class="rem">//-----------------------------------------------------<A name="sbool_add_span_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_aa">sbool_add_span_aa</A></SPAN>
    <SPAN class="rem">// Functor.</SPAN>
    <SPAN class="rem">// Add an anti-aliased span</SPAN>
    <SPAN class="rem">// anti-aliasing information, but only X and Length. The function</SPAN>
    <SPAN class="rem">// is compatible with any type of scanlines.</SPAN>
    <SPAN class="rem">//----------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">&gt;</SPAN> 
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_aa">sbool_add_span_aa</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">void</SPAN> <SPAN class="kw1">operator</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator<SPAN class="op">&amp;</SPAN> span<SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> len<SPAN class="op">,</SPAN> 
                          Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                sl<SPAN class="op">.</SPAN>add_span<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> <SPAN class="op">*</SPAN>span<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="kw1">else</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len <SPAN class="op">&gt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::<A href="agg_basics.h.html#cover_type">cover_type</A><SPAN class="op">*</SPAN> covers <SPAN class="op">=</SPAN> span<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                sl<SPAN class="op">.</SPAN>add_cells<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> covers<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>




    <SPAN class="rem">//----------------------------------------------<A name="sbool_intersect_spans_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_spans_aa">sbool_intersect_spans_aa</A></SPAN>
    <SPAN class="rem">// Functor.</SPAN>
    <SPAN class="rem">// Intersect two spans preserving the anti-aliasing information.</SPAN>
    <SPAN class="rem">// The result is added to the &quot;sl&quot; scanline.</SPAN>
    <SPAN class="rem">//------------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">unsigned</SPAN> CoverShift <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">&gt;</SPAN> 
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_spans_aa">sbool_intersect_spans_aa</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">enum</SPAN> cover_scale_e
        <SPAN class="op">{</SPAN>
            <A href="agg_basics.h.html#cover_shift">cover_shift</A> <SPAN class="op">=</SPAN> CoverShift<SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_size">cover_size</A>  <SPAN class="op">=</SPAN> <SPAN class="num">1</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_mask">cover_mask</A>  <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_size">cover_size</A> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_full">cover_full</A>  <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A>
        <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>
        

        <SPAN class="kw1">void</SPAN> <SPAN class="kw1">operator</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator<SPAN class="op">&amp;</SPAN> span1<SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline2::const_iterator<SPAN class="op">&amp;</SPAN> span2<SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> len<SPAN class="op">,</SPAN> 
                          Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">unsigned</SPAN> cover<SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::<A href="agg_basics.h.html#cover_type">cover_type</A><SPAN class="op">*</SPAN> covers1<SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline2::<A href="agg_basics.h.html#cover_type">cover_type</A><SPAN class="op">*</SPAN> covers2<SPAN class="op">;</SPAN>

            <SPAN class="rem">// Calculate the operation code and choose the </SPAN>
            <SPAN class="rem">// proper combination algorithm.</SPAN>
            <SPAN class="rem">// 0 = Both spans are of AA type</SPAN>
            <SPAN class="rem">// 1 = span1 is solid, span2 is AA</SPAN>
            <SPAN class="rem">// 2 = span1 is AA, span2 is solid</SPAN>
            <SPAN class="rem">// 3 = Both spans are of solid type</SPAN>
            <SPAN class="rem">//-----------------</SPAN>
            <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">|</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
            <SPAN class="kw1">case</SPAN> <SPAN class="num">0</SPAN>:      <SPAN class="rem">// Both are AA spans</SPAN>
                covers1 <SPAN class="op">=</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                covers2 <SPAN class="op">=</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers1 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers2 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">do</SPAN>
                <SPAN class="op">{</SPAN>
                    cover <SPAN class="op">=</SPAN> <SPAN class="op">*</SPAN>covers1<SPAN class="op">++</SPAN> <SPAN class="op">*</SPAN> <SPAN class="op">*</SPAN>covers2<SPAN class="op">++</SPAN><SPAN class="op">;</SPAN>
                    sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">++</SPAN><SPAN class="op">,</SPAN> 
                                <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                                <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                                <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">1</SPAN>:      <SPAN class="rem">// span1 is solid, span2 is AA</SPAN>
                covers2 <SPAN class="op">=</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers2 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN> <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    sl<SPAN class="op">.</SPAN>add_cells<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> covers2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">do</SPAN>
                    <SPAN class="op">{</SPAN>
                        cover <SPAN class="op">=</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> <SPAN class="op">*</SPAN>covers2<SPAN class="op">++</SPAN><SPAN class="op">;</SPAN>
                        sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">++</SPAN><SPAN class="op">,</SPAN> 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                                    <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">2</SPAN>:      <SPAN class="rem">// span1 is AA, span2 is solid</SPAN>
                covers1 <SPAN class="op">=</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers1 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN> <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    sl<SPAN class="op">.</SPAN>add_cells<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> covers1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">do</SPAN>
                    <SPAN class="op">{</SPAN>
                        cover <SPAN class="op">=</SPAN> <SPAN class="op">*</SPAN>covers1<SPAN class="op">++</SPAN> <SPAN class="op">*</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">++</SPAN><SPAN class="op">,</SPAN> 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                                    <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">3</SPAN>:      <SPAN class="rem">// Both are solid spans</SPAN>
                cover <SPAN class="op">=</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                sl<SPAN class="op">.</SPAN>add_span<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> 
                            <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                            <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                            <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>






    <SPAN class="rem">//--------------------------------------------------<A name="sbool_unite_spans_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_unite_spans_aa">sbool_unite_spans_aa</A></SPAN>
    <SPAN class="rem">// Functor.</SPAN>
    <SPAN class="rem">// Unite two spans preserving the anti-aliasing information.</SPAN>
    <SPAN class="rem">// The result is added to the &quot;sl&quot; scanline.</SPAN>
    <SPAN class="rem">//------------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">unsigned</SPAN> CoverShift <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">&gt;</SPAN> 
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_spans_aa">sbool_unite_spans_aa</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">enum</SPAN> cover_scale_e
        <SPAN class="op">{</SPAN>
            <A href="agg_basics.h.html#cover_shift">cover_shift</A> <SPAN class="op">=</SPAN> CoverShift<SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_size">cover_size</A>  <SPAN class="op">=</SPAN> <SPAN class="num">1</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_mask">cover_mask</A>  <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_size">cover_size</A> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_full">cover_full</A>  <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A>
        <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>
        

        <SPAN class="kw1">void</SPAN> <SPAN class="kw1">operator</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator<SPAN class="op">&amp;</SPAN> span1<SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline2::const_iterator<SPAN class="op">&amp;</SPAN> span2<SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> len<SPAN class="op">,</SPAN> 
                          Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">unsigned</SPAN> cover<SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::<A href="agg_basics.h.html#cover_type">cover_type</A><SPAN class="op">*</SPAN> covers1<SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline2::<A href="agg_basics.h.html#cover_type">cover_type</A><SPAN class="op">*</SPAN> covers2<SPAN class="op">;</SPAN>

            <SPAN class="rem">// Calculate the operation code and choose the </SPAN>
            <SPAN class="rem">// proper combination algorithm.</SPAN>
            <SPAN class="rem">// 0 = Both spans are of AA type</SPAN>
            <SPAN class="rem">// 1 = span1 is solid, span2 is AA</SPAN>
            <SPAN class="rem">// 2 = span1 is AA, span2 is solid</SPAN>
            <SPAN class="rem">// 3 = Both spans are of solid type</SPAN>
            <SPAN class="rem">//-----------------</SPAN>
            <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">|</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
            <SPAN class="kw1">case</SPAN> <SPAN class="num">0</SPAN>:      <SPAN class="rem">// Both are AA spans</SPAN>
                covers1 <SPAN class="op">=</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                covers2 <SPAN class="op">=</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers1 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers2 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">do</SPAN>
                <SPAN class="op">{</SPAN>
                    cover <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> 
                                <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN>covers1<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> 
                                <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN>covers2<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">++</SPAN><SPAN class="op">,</SPAN> 
                                <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                                <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                                <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">1</SPAN>:      <SPAN class="rem">// span1 is solid, span2 is AA</SPAN>
                covers2 <SPAN class="op">=</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers2 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN> <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    sl<SPAN class="op">.</SPAN>add_span<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">do</SPAN>
                    <SPAN class="op">{</SPAN>
                        cover <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> 
                                    <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> 
                                    <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN>covers2<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">++</SPAN><SPAN class="op">,</SPAN> 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                                    <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">2</SPAN>:      <SPAN class="rem">// span1 is AA, span2 is solid</SPAN>
                covers1 <SPAN class="op">=</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers1 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN> <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    sl<SPAN class="op">.</SPAN>add_span<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">do</SPAN>
                    <SPAN class="op">{</SPAN>
                        cover <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> 
                                    <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN>covers1<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> 
                                    <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">++</SPAN><SPAN class="op">,</SPAN> 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                                    <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">3</SPAN>:      <SPAN class="rem">// Both are solid spans</SPAN>
                cover <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> 
                            <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> 
                            <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                sl<SPAN class="op">.</SPAN>add_span<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> 
                            <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                            <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                            <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>


    <SPAN class="rem">//---------------------------------------------<A name="sbool_xor_formula_linear"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_xor_formula_linear">sbool_xor_formula_linear</A></SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">unsigned</SPAN> CoverShift <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">&gt;</SPAN> 
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_formula_linear">sbool_xor_formula_linear</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">enum</SPAN> cover_scale_e
        <SPAN class="op">{</SPAN>
            <A href="agg_basics.h.html#cover_shift">cover_shift</A> <SPAN class="op">=</SPAN> CoverShift<SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_size">cover_size</A>  <SPAN class="op">=</SPAN> <SPAN class="num">1</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_mask">cover_mask</A>  <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_size">cover_size</A> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN>
        <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">static</SPAN> AGG_INLINE <SPAN class="kw1">unsigned</SPAN> calculate<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> a<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> b<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">unsigned</SPAN> cover <SPAN class="op">=</SPAN> a <SPAN class="op">+</SPAN> b<SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A><SPAN class="op">)</SPAN> cover <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">+</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> cover<SPAN class="op">;</SPAN>
            <SPAN class="kw1">return</SPAN> cover<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>


    <SPAN class="rem">//---------------------------------------------<A name="sbool_xor_formula_saddle"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_xor_formula_saddle">sbool_xor_formula_saddle</A></SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">unsigned</SPAN> CoverShift <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">&gt;</SPAN> 
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_formula_saddle">sbool_xor_formula_saddle</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">enum</SPAN> cover_scale_e
        <SPAN class="op">{</SPAN>
            <A href="agg_basics.h.html#cover_shift">cover_shift</A> <SPAN class="op">=</SPAN> CoverShift<SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_size">cover_size</A>  <SPAN class="op">=</SPAN> <SPAN class="num">1</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_mask">cover_mask</A>  <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_size">cover_size</A> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN>
        <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">static</SPAN> AGG_INLINE <SPAN class="kw1">unsigned</SPAN> calculate<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> a<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> b<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">unsigned</SPAN> k <SPAN class="op">=</SPAN> a <SPAN class="op">*</SPAN> b<SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>k <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>

            a <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">(</SPAN>a <SPAN class="op">&lt;&lt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> k<SPAN class="op">)</SPAN> <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">;</SPAN>
            b <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">(</SPAN>b <SPAN class="op">&lt;&lt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> k<SPAN class="op">)</SPAN> <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">;</SPAN>
            <SPAN class="kw1">return</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">(</SPAN>a <SPAN class="op">*</SPAN> b<SPAN class="op">)</SPAN> <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>


    <SPAN class="rem">//-------------------------------------------<A name="sbool_xor_formula_abs_diff"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_xor_formula_abs_diff">sbool_xor_formula_abs_diff</A></SPAN>
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_formula_abs_diff">sbool_xor_formula_abs_diff</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">static</SPAN> AGG_INLINE <SPAN class="kw1">unsigned</SPAN> calculate<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> a<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> b<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">return</SPAN> <SPAN class="kw1">unsigned</SPAN><SPAN class="op">(</SPAN>abs<SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>a<SPAN class="op">)</SPAN> <SPAN class="op">-</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>b<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>



    <SPAN class="rem">//----------------------------------------------------<A name="sbool_xor_spans_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_xor_spans_aa">sbool_xor_spans_aa</A></SPAN>
    <SPAN class="rem">// Functor.</SPAN>
    <SPAN class="rem">// XOR two spans preserving the anti-aliasing information.</SPAN>
    <SPAN class="rem">// The result is added to the &quot;sl&quot; scanline.</SPAN>
    <SPAN class="rem">//------------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> XorFormula<SPAN class="op">,</SPAN>
             <SPAN class="kw1">unsigned</SPAN> CoverShift <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">&gt;</SPAN> 
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_spans_aa">sbool_xor_spans_aa</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">enum</SPAN> cover_scale_e
        <SPAN class="op">{</SPAN>
            <A href="agg_basics.h.html#cover_shift">cover_shift</A> <SPAN class="op">=</SPAN> CoverShift<SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_size">cover_size</A>  <SPAN class="op">=</SPAN> <SPAN class="num">1</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_mask">cover_mask</A>  <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_size">cover_size</A> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_full">cover_full</A>  <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A>
        <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>
        

        <SPAN class="kw1">void</SPAN> <SPAN class="kw1">operator</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator<SPAN class="op">&amp;</SPAN> span1<SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline2::const_iterator<SPAN class="op">&amp;</SPAN> span2<SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> len<SPAN class="op">,</SPAN> 
                          Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">unsigned</SPAN> cover<SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::<A href="agg_basics.h.html#cover_type">cover_type</A><SPAN class="op">*</SPAN> covers1<SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline2::<A href="agg_basics.h.html#cover_type">cover_type</A><SPAN class="op">*</SPAN> covers2<SPAN class="op">;</SPAN>

            <SPAN class="rem">// Calculate the operation code and choose the </SPAN>
            <SPAN class="rem">// proper combination algorithm.</SPAN>
            <SPAN class="rem">// 0 = Both spans are of AA type</SPAN>
            <SPAN class="rem">// 1 = span1 is solid, span2 is AA</SPAN>
            <SPAN class="rem">// 2 = span1 is AA, span2 is solid</SPAN>
            <SPAN class="rem">// 3 = Both spans are of solid type</SPAN>
            <SPAN class="rem">//-----------------</SPAN>
            <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">|</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
            <SPAN class="kw1">case</SPAN> <SPAN class="num">0</SPAN>:      <SPAN class="rem">// Both are AA spans</SPAN>
                covers1 <SPAN class="op">=</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                covers2 <SPAN class="op">=</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers1 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers2 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">do</SPAN>
                <SPAN class="op">{</SPAN>
                    cover <SPAN class="op">=</SPAN> XorFormula::calculate<SPAN class="op">(</SPAN><SPAN class="op">*</SPAN>covers1<SPAN class="op">++</SPAN><SPAN class="op">,</SPAN> <SPAN class="op">*</SPAN>covers2<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>cover<SPAN class="op">)</SPAN> sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> cover<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">++</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">1</SPAN>:      <SPAN class="rem">// span1 is solid, span2 is AA</SPAN>
                covers2 <SPAN class="op">=</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers2 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">do</SPAN>
                <SPAN class="op">{</SPAN>
                    cover <SPAN class="op">=</SPAN> XorFormula::calculate<SPAN class="op">(</SPAN><SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> <SPAN class="op">*</SPAN>covers2<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>cover<SPAN class="op">)</SPAN> sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> cover<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">++</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">2</SPAN>:      <SPAN class="rem">// span1 is AA, span2 is solid</SPAN>
                covers1 <SPAN class="op">=</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers1 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">do</SPAN>
                <SPAN class="op">{</SPAN>
                    cover <SPAN class="op">=</SPAN> XorFormula::calculate<SPAN class="op">(</SPAN><SPAN class="op">*</SPAN>covers1<SPAN class="op">++</SPAN><SPAN class="op">,</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>cover<SPAN class="op">)</SPAN> sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> cover<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">++</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">3</SPAN>:      <SPAN class="rem">// Both are solid spans</SPAN>
                cover <SPAN class="op">=</SPAN> XorFormula::calculate<SPAN class="op">(</SPAN><SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>cover<SPAN class="op">)</SPAN> sl<SPAN class="op">.</SPAN>add_span<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> cover<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>





    <SPAN class="rem">//-----------------------------------------------<A name="sbool_subtract_spans_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_spans_aa">sbool_subtract_spans_aa</A></SPAN>
    <SPAN class="rem">// Functor.</SPAN>
    <SPAN class="rem">// Unite two spans preserving the anti-aliasing information.</SPAN>
    <SPAN class="rem">// The result is added to the &quot;sl&quot; scanline.</SPAN>
    <SPAN class="rem">//------------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">unsigned</SPAN> CoverShift <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">&gt;</SPAN> 
    <SPAN class="kw1">struct</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_spans_aa">sbool_subtract_spans_aa</A>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">enum</SPAN> cover_scale_e
        <SPAN class="op">{</SPAN>
            <A href="agg_basics.h.html#cover_shift">cover_shift</A> <SPAN class="op">=</SPAN> CoverShift<SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_size">cover_size</A>  <SPAN class="op">=</SPAN> <SPAN class="num">1</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_mask">cover_mask</A>  <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_size">cover_size</A> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN>
            <A href="agg_basics.h.html#cover_full">cover_full</A>  <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#cover_mask">cover_mask</A>
        <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>
        

        <SPAN class="kw1">void</SPAN> <SPAN class="kw1">operator</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator<SPAN class="op">&amp;</SPAN> span1<SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline2::const_iterator<SPAN class="op">&amp;</SPAN> span2<SPAN class="op">,</SPAN> 
                          <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> len<SPAN class="op">,</SPAN> 
                          Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">unsigned</SPAN> cover<SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline1::<A href="agg_basics.h.html#cover_type">cover_type</A><SPAN class="op">*</SPAN> covers1<SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> <SPAN class="kw1">typename</SPAN> Scanline2::<A href="agg_basics.h.html#cover_type">cover_type</A><SPAN class="op">*</SPAN> covers2<SPAN class="op">;</SPAN>

            <SPAN class="rem">// Calculate the operation code and choose the </SPAN>
            <SPAN class="rem">// proper combination algorithm.</SPAN>
            <SPAN class="rem">// 0 = Both spans are of AA type</SPAN>
            <SPAN class="rem">// 1 = span1 is solid, span2 is AA</SPAN>
            <SPAN class="rem">// 2 = span1 is AA, span2 is solid</SPAN>
            <SPAN class="rem">// 3 = Both spans are of solid type</SPAN>
            <SPAN class="rem">//-----------------</SPAN>
            <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">|</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
            <SPAN class="kw1">case</SPAN> <SPAN class="num">0</SPAN>:      <SPAN class="rem">// Both are AA spans</SPAN>
                covers1 <SPAN class="op">=</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                covers2 <SPAN class="op">=</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers1 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers2 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">do</SPAN>
                <SPAN class="op">{</SPAN>
                    cover <SPAN class="op">=</SPAN> <SPAN class="op">*</SPAN>covers1<SPAN class="op">++</SPAN> <SPAN class="op">*</SPAN> <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN>covers2<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>cover<SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                                    <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="op">++</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">1</SPAN>:      <SPAN class="rem">// span1 is solid, span2 is AA</SPAN>
                covers2 <SPAN class="op">=</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers2 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">do</SPAN>
                <SPAN class="op">{</SPAN>
                    cover <SPAN class="op">=</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN>covers2<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>cover<SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                                    <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                                    <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="op">++</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">2</SPAN>:      <SPAN class="rem">// span1 is AA, span2 is solid</SPAN>
                covers1 <SPAN class="op">=</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x <SPAN class="op">&lt;</SPAN> x<SPAN class="op">)</SPAN> covers1 <SPAN class="op">+=</SPAN> x <SPAN class="op">-</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN> <SPAN class="op">!=</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">do</SPAN>
                    <SPAN class="op">{</SPAN>
                        cover <SPAN class="op">=</SPAN> <SPAN class="op">*</SPAN>covers1<SPAN class="op">++</SPAN> <SPAN class="op">*</SPAN> <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>cover<SPAN class="op">)</SPAN>
                        <SPAN class="op">{</SPAN>
                            sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> 
                                        <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                                        <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                                        <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="op">}</SPAN>
                        <SPAN class="op">++</SPAN>x<SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> <SPAN class="num">3</SPAN>:      <SPAN class="rem">// Both are solid spans</SPAN>
                cover <SPAN class="op">=</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> <SPAN class="op">(</SPAN><A href="agg_basics.h.html#cover_mask">cover_mask</A> <SPAN class="op">-</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>covers<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>cover<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    sl<SPAN class="op">.</SPAN>add_span<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> 
                                <SPAN class="op">(</SPAN>cover <SPAN class="op">==</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A> <SPAN class="op">*</SPAN> <A href="agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN> ?
                                <A href="agg_basics.h.html#cover_full">cover_full</A> : 
                                <SPAN class="op">(</SPAN>cover <SPAN class="op">&gt;&gt;</SPAN> <A href="agg_basics.h.html#cover_shift">cover_shift</A><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>






    <SPAN class="rem">//--------------------------------------------<A name="sbool_add_spans_and_render"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_add_spans_and_render">sbool_add_spans_and_render</A></SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> AddSpanFunctor<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_add_spans_and_render">sbool_add_spans_and_render</A><SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> 
                                    Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> 
                                    Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">,</SPAN> 
                                    AddSpanFunctor add_span<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        sl<SPAN class="op">.</SPAN>reset_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator span <SPAN class="op">=</SPAN> sl1<SPAN class="op">.</SPAN>begin<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">unsigned</SPAN> num_spans <SPAN class="op">=</SPAN> sl1<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN><SPAN class="op">;</SPAN><SPAN class="op">;</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            add_span<SPAN class="op">(</SPAN>span<SPAN class="op">,</SPAN> span<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">,</SPAN> abs<SPAN class="op">(</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">)</SPAN>span<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">--</SPAN>num_spans <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">++</SPAN>span<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        sl<SPAN class="op">.</SPAN>finalize<SPAN class="op">(</SPAN>sl1<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        ren<SPAN class="op">.</SPAN>render<SPAN class="op">(</SPAN>sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>







    <SPAN class="rem">//---------------------------------------------<A name="sbool_intersect_scanlines"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_scanlines">sbool_intersect_scanlines</A></SPAN>
    <SPAN class="rem">// Intersect two scanlines, &quot;sl1&quot; and &quot;sl2&quot; and generate a new &quot;sl&quot; one.</SPAN>
    <SPAN class="rem">// The combine_spans functor can be of type <A href="agg_scanline_boolean_algebra.h.html#sbool_combine_spans_bin">sbool_combine_spans_bin</A> or</SPAN>
    <SPAN class="rem">// <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_spans_aa">sbool_intersect_spans_aa</A>. First is a general functor to combine</SPAN>
    <SPAN class="rem">// two spans without Anti-Aliasing, the second preserves the AA</SPAN>
    <SPAN class="rem">// information, but works slower</SPAN>
    <SPAN class="rem">//</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> CombineSpansFunctor<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_scanlines">sbool_intersect_scanlines</A><SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> 
                                   <SPAN class="kw1">const</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN> 
                                   Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> 
                                   CombineSpansFunctor combine_spans<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        sl<SPAN class="op">.</SPAN>reset_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">unsigned</SPAN> num1 <SPAN class="op">=</SPAN> sl1<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>num1 <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">unsigned</SPAN> num2 <SPAN class="op">=</SPAN> sl2<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>num2 <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator span1 <SPAN class="op">=</SPAN> sl1<SPAN class="op">.</SPAN>begin<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">typename</SPAN> Scanline2::const_iterator span2 <SPAN class="op">=</SPAN> sl2<SPAN class="op">.</SPAN>begin<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN>num1 <SPAN class="op">&amp;&amp;</SPAN> num2<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">int</SPAN> xb1 <SPAN class="op">=</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> xb2 <SPAN class="op">=</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> xe1 <SPAN class="op">=</SPAN> xb1 <SPAN class="op">+</SPAN> abs<SPAN class="op">(</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">)</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len<SPAN class="op">)</SPAN> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> xe2 <SPAN class="op">=</SPAN> xb2 <SPAN class="op">+</SPAN> abs<SPAN class="op">(</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">)</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len<SPAN class="op">)</SPAN> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="rem">// Determine what spans we should advance in the next step</SPAN>
            <SPAN class="rem">// The span with the least ending X should be advanced</SPAN>
            <SPAN class="rem">// advance_both is just an optimization when we ending </SPAN>
            <SPAN class="rem">// coordinates are the same and we can advance both</SPAN>
            <SPAN class="rem">//--------------</SPAN>
            <SPAN class="kw1">bool</SPAN> advance_span1 <SPAN class="op">=</SPAN> xe1 <SPAN class="op">&lt;</SPAN>  xe2<SPAN class="op">;</SPAN>
            <SPAN class="kw1">bool</SPAN> advance_both  <SPAN class="op">=</SPAN> xe1 <SPAN class="op">==</SPAN> xe2<SPAN class="op">;</SPAN>

            <SPAN class="rem">// Find the intersection of the spans</SPAN>
            <SPAN class="rem">// and check if they intersect</SPAN>
            <SPAN class="rem">//--------------</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xb1 <SPAN class="op">&lt;</SPAN> xb2<SPAN class="op">)</SPAN> xb1 <SPAN class="op">=</SPAN> xb2<SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xe1 <SPAN class="op">&gt;</SPAN> xe2<SPAN class="op">)</SPAN> xe1 <SPAN class="op">=</SPAN> xe2<SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xb1 <SPAN class="op">&lt;=</SPAN> xe1<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                combine_spans<SPAN class="op">(</SPAN>span1<SPAN class="op">,</SPAN> span2<SPAN class="op">,</SPAN> xb1<SPAN class="op">,</SPAN> xe1 <SPAN class="op">-</SPAN> xb1 <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN> sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            <SPAN class="rem">// Advance the spans</SPAN>
            <SPAN class="rem">//--------------</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>advance_both<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="op">--</SPAN>num1<SPAN class="op">;</SPAN>
                <SPAN class="op">--</SPAN>num2<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>num1<SPAN class="op">)</SPAN> <SPAN class="op">++</SPAN>span1<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>num2<SPAN class="op">)</SPAN> <SPAN class="op">++</SPAN>span2<SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="kw1">else</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>advance_span1<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="op">--</SPAN>num1<SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>num1<SPAN class="op">)</SPAN> <SPAN class="op">++</SPAN>span1<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="op">--</SPAN>num2<SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>num2<SPAN class="op">)</SPAN> <SPAN class="op">++</SPAN>span2<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>








    <SPAN class="rem">//------------------------------------------------<A name="sbool_intersect_shapes"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_shapes">sbool_intersect_shapes</A></SPAN>
    <SPAN class="rem">// Intersect the scanline shapes. Here the &quot;Scanline Generator&quot; </SPAN>
    <SPAN class="rem">// abstraction is used. ScanlineGen1 and ScanlineGen2 are </SPAN>
    <SPAN class="rem">// the generators, and can be of type <A href="agg_rasterizer_scanline_aa.h.html#rasterizer_scanline_aa">rasterizer_scanline_aa</A>&lt;&gt;.</SPAN>
    <SPAN class="rem">// There function requires three scanline containers that can be of</SPAN>
    <SPAN class="rem">// different types.</SPAN>
    <SPAN class="rem">// &quot;sl1&quot; and &quot;sl2&quot; are used to retrieve scanlines from the generators,</SPAN>
    <SPAN class="rem">// &quot;sl&quot; is ised as the resulting scanline to render it.</SPAN>
    <SPAN class="rem">// The external &quot;sl1&quot; and &quot;sl2&quot; are used only for the sake of</SPAN>
    <SPAN class="rem">// optimization and reusing of the scanline objects.</SPAN>
    <SPAN class="rem">// the function calls <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_scanlines">sbool_intersect_scanlines</A> with CombineSpansFunctor </SPAN>
    <SPAN class="rem">// as the last argument. See <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_scanlines">sbool_intersect_scanlines</A> for details.</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">,</SPAN>
             <SPAN class="kw1">class</SPAN> CombineSpansFunctor<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_shapes">sbool_intersect_shapes</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                                Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                                Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">,</SPAN> 
                                CombineSpansFunctor combine_spans<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="rem">// Prepare the scanline generators.</SPAN>
        <SPAN class="rem">// If anyone of them doesn&#039;t contain </SPAN>
        <SPAN class="rem">// any scanlines, then return.</SPAN>
        <SPAN class="rem">//-----------------</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>sg1<SPAN class="op">.</SPAN>rewind_scanlines<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>sg2<SPAN class="op">.</SPAN>rewind_scanlines<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="rem">// Get the bounding boxes</SPAN>
        <SPAN class="rem">//----------------</SPAN>
        <A href="agg_basics.h.html#rect_i">rect_i</A> r1<SPAN class="op">(</SPAN>sg1<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <A href="agg_basics.h.html#rect_i">rect_i</A> r2<SPAN class="op">(</SPAN>sg2<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg2<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg2<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg2<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="rem">// Calculate the intersection of the bounding </SPAN>
        <SPAN class="rem">// boxes and return if they don&#039;t intersect.</SPAN>
        <SPAN class="rem">//-----------------</SPAN>
        <A href="agg_basics.h.html#rect_i">rect_i</A> ir <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#intersect_rectangles">intersect_rectangles</A><SPAN class="op">(</SPAN>r1<SPAN class="op">,</SPAN> r2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>ir<SPAN class="op">.</SPAN>is_valid<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="rem">// Reset the scanlines and get two first ones</SPAN>
        <SPAN class="rem">//-----------------</SPAN>
        sl<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>ir<SPAN class="op">.</SPAN>x1<SPAN class="op">,</SPAN> ir<SPAN class="op">.</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        sl1<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>sg1<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        sl2<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>sg2<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg2<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>sg1<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>sg2<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>

        ren<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="rem">// The main loop</SPAN>
        <SPAN class="rem">// Here we synchronize the scanlines with </SPAN>
        <SPAN class="rem">// the same Y coordinate, ignoring all other ones.</SPAN>
        <SPAN class="rem">// Only scanlines having the same Y-coordinate </SPAN>
        <SPAN class="rem">// are to be combined.</SPAN>
        <SPAN class="rem">//-----------------</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN><SPAN class="op">;</SPAN><SPAN class="op">;</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN>sl1<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&lt;</SPAN> sl2<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>sg1<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN>sl2<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&lt;</SPAN> sl1<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>sg2<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>sl1<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">==</SPAN> sl2<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="rem">// The Y coordinates are the same.</SPAN>
                <SPAN class="rem">// Combine the scanlines, render if they contain any spans,</SPAN>
                <SPAN class="rem">// and advance both generators to the next scanlines</SPAN>
                <SPAN class="rem">//----------------------</SPAN>
                <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_scanlines">sbool_intersect_scanlines</A><SPAN class="op">(</SPAN>sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> combine_spans<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>sl<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    sl<SPAN class="op">.</SPAN>finalize<SPAN class="op">(</SPAN>sl1<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    ren<SPAN class="op">.</SPAN>render<SPAN class="op">(</SPAN>sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>sg1<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>sg2<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>







    <SPAN class="rem">//-------------------------------------------------<A name="sbool_unite_scanlines"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_unite_scanlines">sbool_unite_scanlines</A></SPAN>
    <SPAN class="rem">// Unite two scanlines, &quot;sl1&quot; and &quot;sl2&quot; and generate a new &quot;sl&quot; one.</SPAN>
    <SPAN class="rem">// The combine_spans functor can be of type <A href="agg_scanline_boolean_algebra.h.html#sbool_combine_spans_bin">sbool_combine_spans_bin</A> or</SPAN>
    <SPAN class="rem">// <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_spans_aa">sbool_intersect_spans_aa</A>. First is a general functor to combine</SPAN>
    <SPAN class="rem">// two spans without Anti-Aliasing, the second preserves the AA</SPAN>
    <SPAN class="rem">// information, but works slower</SPAN>
    <SPAN class="rem">//</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> AddSpanFunctor1<SPAN class="op">,</SPAN>
             <SPAN class="kw1">class</SPAN> AddSpanFunctor2<SPAN class="op">,</SPAN>
             <SPAN class="kw1">class</SPAN> CombineSpansFunctor<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_scanlines">sbool_unite_scanlines</A><SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> 
                               <SPAN class="kw1">const</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN> 
                               Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> 
                               AddSpanFunctor1 add_span1<SPAN class="op">,</SPAN>
                               AddSpanFunctor2 add_span2<SPAN class="op">,</SPAN>
                               CombineSpansFunctor combine_spans<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        sl<SPAN class="op">.</SPAN>reset_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">unsigned</SPAN> num1 <SPAN class="op">=</SPAN> sl1<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">unsigned</SPAN> num2 <SPAN class="op">=</SPAN> sl2<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">typename</SPAN> Scanline1::const_iterator span1<SPAN class="op">;</SPAN><SPAN class="rem">// = sl1.begin();</SPAN>
        <SPAN class="kw1">typename</SPAN> Scanline2::const_iterator span2<SPAN class="op">;</SPAN><SPAN class="rem">// = sl2.begin();</SPAN>

        <SPAN class="kw1">enum</SPAN> invalidation_e 
        <SPAN class="op">{</SPAN> 
            invalid_b <SPAN class="op">=</SPAN> <SPAN class="num">0xFFFFFFF</SPAN><SPAN class="op">,</SPAN> 
            invalid_e <SPAN class="op">=</SPAN> invalid_b <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN> 
        <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="rem">// Initialize the spans as invalid</SPAN>
        <SPAN class="rem">//---------------</SPAN>
        <SPAN class="kw1">int</SPAN> xb1 <SPAN class="op">=</SPAN> invalid_b<SPAN class="op">;</SPAN>
        <SPAN class="kw1">int</SPAN> xb2 <SPAN class="op">=</SPAN> invalid_b<SPAN class="op">;</SPAN>
        <SPAN class="kw1">int</SPAN> xe1 <SPAN class="op">=</SPAN> invalid_e<SPAN class="op">;</SPAN>
        <SPAN class="kw1">int</SPAN> xe2 <SPAN class="op">=</SPAN> invalid_e<SPAN class="op">;</SPAN>

        <SPAN class="rem">// Initialize span1 if there are spans</SPAN>
        <SPAN class="rem">//---------------</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>num1<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            span1 <SPAN class="op">=</SPAN> sl1<SPAN class="op">.</SPAN>begin<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            xb1 <SPAN class="op">=</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
            xe1 <SPAN class="op">=</SPAN> xb1 <SPAN class="op">+</SPAN> abs<SPAN class="op">(</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">)</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len<SPAN class="op">)</SPAN> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">--</SPAN>num1<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>

        <SPAN class="rem">// Initialize span2 if there are spans</SPAN>
        <SPAN class="rem">//---------------</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>num2<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            span2 <SPAN class="op">=</SPAN> sl2<SPAN class="op">.</SPAN>begin<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            xb2 <SPAN class="op">=</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
            xe2 <SPAN class="op">=</SPAN> xb2 <SPAN class="op">+</SPAN> abs<SPAN class="op">(</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">)</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len<SPAN class="op">)</SPAN> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">--</SPAN>num2<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>


        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN><SPAN class="op">;</SPAN><SPAN class="op">;</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="rem">// Retrieve a new span1 if it&#039;s invalid</SPAN>
            <SPAN class="rem">//----------------</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>num1 <SPAN class="op">&amp;&amp;</SPAN> xb1 <SPAN class="op">&gt;</SPAN> xe1<SPAN class="op">)</SPAN> 
            <SPAN class="op">{</SPAN>
                <SPAN class="op">--</SPAN>num1<SPAN class="op">;</SPAN>
                <SPAN class="op">++</SPAN>span1<SPAN class="op">;</SPAN>
                xb1 <SPAN class="op">=</SPAN> span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                xe1 <SPAN class="op">=</SPAN> xb1 <SPAN class="op">+</SPAN> abs<SPAN class="op">(</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">)</SPAN>span1<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len<SPAN class="op">)</SPAN> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            <SPAN class="rem">// Retrieve a new span2 if it&#039;s invalid</SPAN>
            <SPAN class="rem">//----------------</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>num2 <SPAN class="op">&amp;&amp;</SPAN> xb2 <SPAN class="op">&gt;</SPAN> xe2<SPAN class="op">)</SPAN> 
            <SPAN class="op">{</SPAN>
                <SPAN class="op">--</SPAN>num2<SPAN class="op">;</SPAN>
                <SPAN class="op">++</SPAN>span2<SPAN class="op">;</SPAN>
                xb2 <SPAN class="op">=</SPAN> span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>x<SPAN class="op">;</SPAN>
                xe2 <SPAN class="op">=</SPAN> xb2 <SPAN class="op">+</SPAN> abs<SPAN class="op">(</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">)</SPAN>span2<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>len<SPAN class="op">)</SPAN> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xb1 <SPAN class="op">&gt;</SPAN> xe1 <SPAN class="op">&amp;&amp;</SPAN> xb2 <SPAN class="op">&gt;</SPAN> xe2<SPAN class="op">)</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="rem">// Calculate the intersection</SPAN>
            <SPAN class="rem">//----------------</SPAN>
            <SPAN class="kw1">int</SPAN> xb <SPAN class="op">=</SPAN> xb1<SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> xe <SPAN class="op">=</SPAN> xe1<SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xb <SPAN class="op">&lt;</SPAN> xb2<SPAN class="op">)</SPAN> xb <SPAN class="op">=</SPAN> xb2<SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xe <SPAN class="op">&gt;</SPAN> xe2<SPAN class="op">)</SPAN> xe <SPAN class="op">=</SPAN> xe2<SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> len <SPAN class="op">=</SPAN> xe <SPAN class="op">-</SPAN> xb <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> <SPAN class="rem">// The length of the intersection</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>len <SPAN class="op">&gt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="rem">// The spans intersect,</SPAN>
                <SPAN class="rem">// add the beginning of the span</SPAN>
                <SPAN class="rem">//----------------</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xb1 <SPAN class="op">&lt;</SPAN> xb2<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    add_span1<SPAN class="op">(</SPAN>span1<SPAN class="op">,</SPAN> xb1<SPAN class="op">,</SPAN> xb2 <SPAN class="op">-</SPAN> xb1<SPAN class="op">,</SPAN> sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    xb1 <SPAN class="op">=</SPAN> xb2<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xb2 <SPAN class="op">&lt;</SPAN> xb1<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    add_span2<SPAN class="op">(</SPAN>span2<SPAN class="op">,</SPAN> xb2<SPAN class="op">,</SPAN> xb1 <SPAN class="op">-</SPAN> xb2<SPAN class="op">,</SPAN> sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    xb2 <SPAN class="op">=</SPAN> xb1<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>

                <SPAN class="rem">// Add the combination part of the spans</SPAN>
                <SPAN class="rem">//----------------</SPAN>
                combine_spans<SPAN class="op">(</SPAN>span1<SPAN class="op">,</SPAN> span2<SPAN class="op">,</SPAN> xb<SPAN class="op">,</SPAN> len<SPAN class="op">,</SPAN> sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>


                <SPAN class="rem">// Invalidate the fully processed span or both</SPAN>
                <SPAN class="rem">//----------------</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xe1 <SPAN class="op">&lt;</SPAN> xe2<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="rem">// Invalidate span1 and eat</SPAN>
                    <SPAN class="rem">// the processed part of span2</SPAN>
                    <SPAN class="rem">//--------------</SPAN>
                    xb1 <SPAN class="op">=</SPAN> invalid_b<SPAN class="op">;</SPAN>    
                    xe1 <SPAN class="op">=</SPAN> invalid_e<SPAN class="op">;</SPAN>
                    xb2 <SPAN class="op">+=</SPAN> len<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xe2 <SPAN class="op">&lt;</SPAN> xe1<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="rem">// Invalidate span2 and eat</SPAN>
                    <SPAN class="rem">// the processed part of span1</SPAN>
                    <SPAN class="rem">//--------------</SPAN>
                    xb2 <SPAN class="op">=</SPAN> invalid_b<SPAN class="op">;</SPAN>  
                    xe2 <SPAN class="op">=</SPAN> invalid_e<SPAN class="op">;</SPAN>
                    xb1 <SPAN class="op">+=</SPAN> len<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    xb1 <SPAN class="op">=</SPAN> invalid_b<SPAN class="op">;</SPAN>  <SPAN class="rem">// Invalidate both</SPAN>
                    xb2 <SPAN class="op">=</SPAN> invalid_b<SPAN class="op">;</SPAN>
                    xe1 <SPAN class="op">=</SPAN> invalid_e<SPAN class="op">;</SPAN>
                    xe2 <SPAN class="op">=</SPAN> invalid_e<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="kw1">else</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="rem">// The spans do not intersect</SPAN>
                <SPAN class="rem">//--------------</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xb1 <SPAN class="op">&lt;</SPAN> xb2<SPAN class="op">)</SPAN> 
                <SPAN class="op">{</SPAN>
                    <SPAN class="rem">// Advance span1</SPAN>
                    <SPAN class="rem">//---------------</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xb1 <SPAN class="op">&lt;=</SPAN> xe1<SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        add_span1<SPAN class="op">(</SPAN>span1<SPAN class="op">,</SPAN> xb1<SPAN class="op">,</SPAN> xe1 <SPAN class="op">-</SPAN> xb1 <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN> sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    xb1 <SPAN class="op">=</SPAN> invalid_b<SPAN class="op">;</SPAN> <SPAN class="rem">// Invalidate</SPAN>
                    xe1 <SPAN class="op">=</SPAN> invalid_e<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="rem">// Advance span2</SPAN>
                    <SPAN class="rem">//---------------</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>xb2 <SPAN class="op">&lt;=</SPAN> xe2<SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        add_span2<SPAN class="op">(</SPAN>span2<SPAN class="op">,</SPAN> xb2<SPAN class="op">,</SPAN> xe2 <SPAN class="op">-</SPAN> xb2 <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN> sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    xb2 <SPAN class="op">=</SPAN> invalid_b<SPAN class="op">;</SPAN> <SPAN class="rem">// Invalidate</SPAN>
                    xe2 <SPAN class="op">=</SPAN> invalid_e<SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>




    <SPAN class="rem">//----------------------------------------------------<A name="sbool_unite_shapes"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes">sbool_unite_shapes</A></SPAN>
    <SPAN class="rem">// Unite the scanline shapes. Here the &quot;Scanline Generator&quot; </SPAN>
    <SPAN class="rem">// abstraction is used. ScanlineGen1 and ScanlineGen2 are </SPAN>
    <SPAN class="rem">// the generators, and can be of type <A href="agg_rasterizer_scanline_aa.h.html#rasterizer_scanline_aa">rasterizer_scanline_aa</A>&lt;&gt;.</SPAN>
    <SPAN class="rem">// There function requires three scanline containers that can be </SPAN>
    <SPAN class="rem">// of different type.</SPAN>
    <SPAN class="rem">// &quot;sl1&quot; and &quot;sl2&quot; are used to retrieve scanlines from the generators,</SPAN>
    <SPAN class="rem">// &quot;sl&quot; is ised as the resulting scanline to render it.</SPAN>
    <SPAN class="rem">// The external &quot;sl1&quot; and &quot;sl2&quot; are used only for the sake of</SPAN>
    <SPAN class="rem">// optimization and reusing of the scanline objects.</SPAN>
    <SPAN class="rem">// the function calls <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_scanlines">sbool_unite_scanlines</A> with CombineSpansFunctor </SPAN>
    <SPAN class="rem">// as the last argument. See <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_scanlines">sbool_unite_scanlines</A> for details.</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">,</SPAN>
             <SPAN class="kw1">class</SPAN> AddSpanFunctor1<SPAN class="op">,</SPAN>
             <SPAN class="kw1">class</SPAN> AddSpanFunctor2<SPAN class="op">,</SPAN>
             <SPAN class="kw1">class</SPAN> CombineSpansFunctor<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes">sbool_unite_shapes</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                            Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                            Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">,</SPAN> 
                            AddSpanFunctor1 add_span1<SPAN class="op">,</SPAN>
                            AddSpanFunctor2 add_span2<SPAN class="op">,</SPAN>
                            CombineSpansFunctor combine_spans<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="rem">// Prepare the scanline generators.</SPAN>
        <SPAN class="rem">// If anyone of them doesn&#039;t contain </SPAN>
        <SPAN class="rem">// any scanlines, then return.</SPAN>
        <SPAN class="rem">//-----------------</SPAN>
        <SPAN class="kw1">bool</SPAN> flag1 <SPAN class="op">=</SPAN> sg1<SPAN class="op">.</SPAN>rewind_scanlines<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">bool</SPAN> flag2 <SPAN class="op">=</SPAN> sg2<SPAN class="op">.</SPAN>rewind_scanlines<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>flag1 <SPAN class="op">&amp;&amp;</SPAN> <SPAN class="op">!</SPAN>flag2<SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="rem">// Get the bounding boxes</SPAN>
        <SPAN class="rem">//----------------</SPAN>
        <A href="agg_basics.h.html#rect_i">rect_i</A> r1<SPAN class="op">(</SPAN>sg1<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <A href="agg_basics.h.html#rect_i">rect_i</A> r2<SPAN class="op">(</SPAN>sg2<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg2<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg2<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg2<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="rem">// Calculate the union of the bounding boxes</SPAN>
        <SPAN class="rem">//-----------------</SPAN>
        <A href="agg_basics.h.html#rect_i">rect_i</A> ur<SPAN class="op">(</SPAN><SPAN class="num">1</SPAN><SPAN class="op">,</SPAN><SPAN class="num">1</SPAN><SPAN class="op">,</SPAN><SPAN class="num">0</SPAN><SPAN class="op">,</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
             <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flag1 <SPAN class="op">&amp;&amp;</SPAN> flag2<SPAN class="op">)</SPAN> ur <SPAN class="op">=</SPAN> <A href="agg_basics.h.html#unite_rectangles">unite_rectangles</A><SPAN class="op">(</SPAN>r1<SPAN class="op">,</SPAN> r2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">else</SPAN> <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flag1<SPAN class="op">)</SPAN>          ur <SPAN class="op">=</SPAN> r1<SPAN class="op">;</SPAN>
        <SPAN class="kw1">else</SPAN> <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flag2<SPAN class="op">)</SPAN>          ur <SPAN class="op">=</SPAN> r2<SPAN class="op">;</SPAN>

        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>ur<SPAN class="op">.</SPAN>is_valid<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>

        ren<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="rem">// Reset the scanlines and get two first ones</SPAN>
        <SPAN class="rem">//-----------------</SPAN>
        sl<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>ur<SPAN class="op">.</SPAN>x1<SPAN class="op">,</SPAN> ur<SPAN class="op">.</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flag1<SPAN class="op">)</SPAN> 
        <SPAN class="op">{</SPAN>
            sl1<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>sg1<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            flag1 <SPAN class="op">=</SPAN> sg1<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>

        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flag2<SPAN class="op">)</SPAN> 
        <SPAN class="op">{</SPAN>
            sl2<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>sg2<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg2<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            flag2 <SPAN class="op">=</SPAN> sg2<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>

        <SPAN class="rem">// The main loop</SPAN>
        <SPAN class="rem">// Here we synchronize the scanlines with </SPAN>
        <SPAN class="rem">// the same Y coordinate.</SPAN>
        <SPAN class="rem">//-----------------</SPAN>
        <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN>flag1 <SPAN class="op">||</SPAN> flag2<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flag1 <SPAN class="op">&amp;&amp;</SPAN> flag2<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>sl1<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">==</SPAN> sl2<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="rem">// The Y coordinates are the same.</SPAN>
                    <SPAN class="rem">// Combine the scanlines, render if they contain any spans,</SPAN>
                    <SPAN class="rem">// and advance both generators to the next scanlines</SPAN>
                    <SPAN class="rem">//----------------------</SPAN>
                    <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_scanlines">sbool_unite_scanlines</A><SPAN class="op">(</SPAN>sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> 
                                          add_span1<SPAN class="op">,</SPAN> add_span2<SPAN class="op">,</SPAN> combine_spans<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>sl<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        sl<SPAN class="op">.</SPAN>finalize<SPAN class="op">(</SPAN>sl1<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        ren<SPAN class="op">.</SPAN>render<SPAN class="op">(</SPAN>sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    flag1 <SPAN class="op">=</SPAN> sg1<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    flag2 <SPAN class="op">=</SPAN> sg2<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>sl1<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&lt;</SPAN> sl2<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_spans_and_render">sbool_add_spans_and_render</A><SPAN class="op">(</SPAN>sl1<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> add_span1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        flag1 <SPAN class="op">=</SPAN> sg1<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="kw1">else</SPAN>
                    <SPAN class="op">{</SPAN>
                        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_spans_and_render">sbool_add_spans_and_render</A><SPAN class="op">(</SPAN>sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> add_span2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        flag2 <SPAN class="op">=</SPAN> sg2<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="kw1">else</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flag1<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <A href="agg_scanline_boolean_algebra.h.html#sbool_add_spans_and_render">sbool_add_spans_and_render</A><SPAN class="op">(</SPAN>sl1<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> add_span1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    flag1 <SPAN class="op">=</SPAN> sg1<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flag2<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <A href="agg_scanline_boolean_algebra.h.html#sbool_add_spans_and_render">sbool_add_spans_and_render</A><SPAN class="op">(</SPAN>sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> add_span2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    flag2 <SPAN class="op">=</SPAN> sg2<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>








    <SPAN class="rem">//-------------------------------------------------<A name="sbool_subtract_shapes"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes">sbool_subtract_shapes</A></SPAN>
    <SPAN class="rem">// Subtract the scanline shapes, &quot;sg1-sg2&quot;. Here the &quot;Scanline Generator&quot; </SPAN>
    <SPAN class="rem">// abstraction is used. ScanlineGen1 and ScanlineGen2 are </SPAN>
    <SPAN class="rem">// the generators, and can be of type <A href="agg_rasterizer_scanline_aa.h.html#rasterizer_scanline_aa">rasterizer_scanline_aa</A>&lt;&gt;.</SPAN>
    <SPAN class="rem">// There function requires three scanline containers that can be of</SPAN>
    <SPAN class="rem">// different types.</SPAN>
    <SPAN class="rem">// &quot;sl1&quot; and &quot;sl2&quot; are used to retrieve scanlines from the generators,</SPAN>
    <SPAN class="rem">// &quot;sl&quot; is ised as the resulting scanline to render it.</SPAN>
    <SPAN class="rem">// The external &quot;sl1&quot; and &quot;sl2&quot; are used only for the sake of</SPAN>
    <SPAN class="rem">// optimization and reusing of the scanline objects.</SPAN>
    <SPAN class="rem">// the function calls <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_scanlines">sbool_intersect_scanlines</A> with CombineSpansFunctor </SPAN>
    <SPAN class="rem">// as the last argument. See combine_scanlines_sub for details.</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">,</SPAN>
             <SPAN class="kw1">class</SPAN> AddSpanFunctor1<SPAN class="op">,</SPAN>
             <SPAN class="kw1">class</SPAN> CombineSpansFunctor<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes">sbool_subtract_shapes</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                               Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                               Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">,</SPAN> 
                               AddSpanFunctor1 add_span1<SPAN class="op">,</SPAN>
                               CombineSpansFunctor combine_spans<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="rem">// Prepare the scanline generators.</SPAN>
        <SPAN class="rem">// Here &quot;sg1&quot; is master, &quot;sg2&quot; is slave.</SPAN>
        <SPAN class="rem">//-----------------</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>sg1<SPAN class="op">.</SPAN>rewind_scanlines<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">bool</SPAN> flag2 <SPAN class="op">=</SPAN> sg2<SPAN class="op">.</SPAN>rewind_scanlines<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="rem">// Get the bounding box</SPAN>
        <SPAN class="rem">//----------------</SPAN>
        <A href="agg_basics.h.html#rect_i">rect_i</A> r1<SPAN class="op">(</SPAN>sg1<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="rem">// Reset the scanlines and get two first ones</SPAN>
        <SPAN class="rem">//-----------------</SPAN>
        sl<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>sg1<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        sl1<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>sg1<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg1<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        sl2<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>sg2<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> sg2<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>sg1<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flag2<SPAN class="op">)</SPAN> flag2 <SPAN class="op">=</SPAN> sg2<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        ren<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="rem">// A fake span2 processor</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_empty">sbool_add_span_empty</A><SPAN class="op">&lt;</SPAN>Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_span2<SPAN class="op">;</SPAN>

        <SPAN class="rem">// The main loop</SPAN>
        <SPAN class="rem">// Here we synchronize the scanlines with </SPAN>
        <SPAN class="rem">// the same Y coordinate, ignoring all other ones.</SPAN>
        <SPAN class="rem">// Only scanlines having the same Y-coordinate </SPAN>
        <SPAN class="rem">// are to be combined.</SPAN>
        <SPAN class="rem">//-----------------</SPAN>
        <SPAN class="kw1">bool</SPAN> flag1 <SPAN class="op">=</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">do</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="rem">// Synchronize &quot;slave&quot; with &quot;master&quot;</SPAN>
            <SPAN class="rem">//-----------------</SPAN>
            <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN>flag2 <SPAN class="op">&amp;&amp;</SPAN> sl2<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&lt;</SPAN> sl1<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                flag2 <SPAN class="op">=</SPAN> sg2<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>


            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flag2 <SPAN class="op">&amp;&amp;</SPAN> sl2<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">==</SPAN> sl1<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="rem">// The Y coordinates are the same.</SPAN>
                <SPAN class="rem">// Combine the scanlines and render if they contain any spans.</SPAN>
                <SPAN class="rem">//----------------------</SPAN>
                <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_scanlines">sbool_unite_scanlines</A><SPAN class="op">(</SPAN>sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> add_span1<SPAN class="op">,</SPAN> add_span2<SPAN class="op">,</SPAN> combine_spans<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>sl<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    sl<SPAN class="op">.</SPAN>finalize<SPAN class="op">(</SPAN>sl1<SPAN class="op">.</SPAN>y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    ren<SPAN class="op">.</SPAN>render<SPAN class="op">(</SPAN>sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="kw1">else</SPAN>
            <SPAN class="op">{</SPAN>
                <A href="agg_scanline_boolean_algebra.h.html#sbool_add_spans_and_render">sbool_add_spans_and_render</A><SPAN class="op">(</SPAN>sl1<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> add_span1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            <SPAN class="rem">// Advance the &quot;master&quot;</SPAN>
            flag1 <SPAN class="op">=</SPAN> sg1<SPAN class="op">.</SPAN>sweep_scanline<SPAN class="op">(</SPAN>sl1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN>flag1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>







    <SPAN class="rem">//---------------------------------------------<A name="sbool_intersect_shapes_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_shapes_aa">sbool_intersect_shapes_aa</A></SPAN>
    <SPAN class="rem">// Intersect two anti-aliased scanline shapes. </SPAN>
    <SPAN class="rem">// Here the &quot;Scanline Generator&quot; abstraction is used. </SPAN>
    <SPAN class="rem">// ScanlineGen1 and ScanlineGen2 are the generators, and can be of </SPAN>
    <SPAN class="rem">// type <A href="agg_rasterizer_scanline_aa.h.html#rasterizer_scanline_aa">rasterizer_scanline_aa</A>&lt;&gt;. There function requires three </SPAN>
    <SPAN class="rem">// scanline containers that can be of different types.</SPAN>
    <SPAN class="rem">// &quot;sl1&quot; and &quot;sl2&quot; are used to retrieve scanlines from the generators,</SPAN>
    <SPAN class="rem">// &quot;sl&quot; is ised as the resulting scanline to render it.</SPAN>
    <SPAN class="rem">// The external &quot;sl1&quot; and &quot;sl2&quot; are used only for the sake of</SPAN>
    <SPAN class="rem">// optimization and reusing of the scanline objects.</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_shapes_aa">sbool_intersect_shapes_aa</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                                   Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                                   Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_spans_aa">sbool_intersect_spans_aa</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> combine_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_shapes">sbool_intersect_shapes</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> combine_functor<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>





    <SPAN class="rem">//--------------------------------------------<A name="sbool_intersect_shapes_bin"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_shapes_bin">sbool_intersect_shapes_bin</A></SPAN>
    <SPAN class="rem">// Intersect two binary scanline shapes (without anti-aliasing). </SPAN>
    <SPAN class="rem">// See intersect_shapes_aa for more comments</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_shapes_bin">sbool_intersect_shapes_bin</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                                    Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                                    Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_combine_spans_bin">sbool_combine_spans_bin</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> combine_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_shapes">sbool_intersect_shapes</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> combine_functor<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>





    <SPAN class="rem">//-------------------------------------------------<A name="sbool_unite_shapes_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes_aa">sbool_unite_shapes_aa</A></SPAN>
    <SPAN class="rem">// Unite two anti-aliased scanline shapes </SPAN>
    <SPAN class="rem">// See intersect_shapes_aa for more comments</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes_aa">sbool_unite_shapes_aa</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                               Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                               Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_aa">sbool_add_span_aa</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor1<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_aa">sbool_add_span_aa</A><SPAN class="op">&lt;</SPAN>Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor2<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_spans_aa">sbool_unite_spans_aa</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> combine_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes">sbool_unite_shapes</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> 
                           add_functor1<SPAN class="op">,</SPAN> add_functor2<SPAN class="op">,</SPAN> combine_functor<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>





    <SPAN class="rem">//------------------------------------------------<A name="sbool_unite_shapes_bin"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes_bin">sbool_unite_shapes_bin</A></SPAN>
    <SPAN class="rem">// Unite two binary scanline shapes (without anti-aliasing). </SPAN>
    <SPAN class="rem">// See intersect_shapes_aa for more comments</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes_bin">sbool_unite_shapes_bin</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                                Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                                Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_bin">sbool_add_span_bin</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor1<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_bin">sbool_add_span_bin</A><SPAN class="op">&lt;</SPAN>Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor2<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_combine_spans_bin">sbool_combine_spans_bin</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> combine_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes">sbool_unite_shapes</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> 
                           add_functor1<SPAN class="op">,</SPAN> add_functor2<SPAN class="op">,</SPAN> combine_functor<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>









    <SPAN class="rem">//---------------------------------------------------<A name="sbool_xor_shapes_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_aa">sbool_xor_shapes_aa</A></SPAN>
    <SPAN class="rem">// Apply eXclusive OR to two anti-aliased scanline shapes. There&#039;s </SPAN>
    <SPAN class="rem">// a modified &quot;Linear&quot; XOR used instead of classical &quot;Saddle&quot; one.</SPAN>
    <SPAN class="rem">// The reason is to have the result absolutely conststent with what</SPAN>
    <SPAN class="rem">// the scanline rasterizer produces.</SPAN>
    <SPAN class="rem">// See intersect_shapes_aa for more comments</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_aa">sbool_xor_shapes_aa</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                             Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                             Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_aa">sbool_add_span_aa</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor1<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_aa">sbool_add_span_aa</A><SPAN class="op">&lt;</SPAN>Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor2<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_spans_aa">sbool_xor_spans_aa</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">,</SPAN> 
                           <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_formula_linear">sbool_xor_formula_linear</A><SPAN class="op">&lt;</SPAN><SPAN class="op">&gt;</SPAN> <SPAN class="op">&gt;</SPAN> combine_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes">sbool_unite_shapes</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> 
                           add_functor1<SPAN class="op">,</SPAN> add_functor2<SPAN class="op">,</SPAN> combine_functor<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------<A name="sbool_xor_shapes_saddle_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_saddle_aa">sbool_xor_shapes_saddle_aa</A></SPAN>
    <SPAN class="rem">// Apply eXclusive OR to two anti-aliased scanline shapes. </SPAN>
    <SPAN class="rem">// There&#039;s the classical &quot;Saddle&quot; used to calculate the </SPAN>
    <SPAN class="rem">// Anti-Aliasing values, that is:</SPAN>
    <SPAN class="rem">// a XOR b : 1-((1-a+a*b)*(1-b+a*b))</SPAN>
    <SPAN class="rem">// See intersect_shapes_aa for more comments</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_saddle_aa">sbool_xor_shapes_saddle_aa</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                                    Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                                    Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_aa">sbool_add_span_aa</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor1<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_aa">sbool_add_span_aa</A><SPAN class="op">&lt;</SPAN>Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor2<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_spans_aa">sbool_xor_spans_aa</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> 
                           Scanline2<SPAN class="op">,</SPAN> 
                           Scanline<SPAN class="op">,</SPAN> 
                           <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_formula_saddle">sbool_xor_formula_saddle</A><SPAN class="op">&lt;</SPAN><SPAN class="op">&gt;</SPAN> <SPAN class="op">&gt;</SPAN> combine_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes">sbool_unite_shapes</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> 
                           add_functor1<SPAN class="op">,</SPAN> add_functor2<SPAN class="op">,</SPAN> combine_functor<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="rem">//--------------------------------------<A name="sbool_xor_shapes_abs_diff_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_abs_diff_aa">sbool_xor_shapes_abs_diff_aa</A></SPAN>
    <SPAN class="rem">// Apply eXclusive OR to two anti-aliased scanline shapes. </SPAN>
    <SPAN class="rem">// There&#039;s the absolute difference used to calculate </SPAN>
    <SPAN class="rem">// Anti-Aliasing values, that is:</SPAN>
    <SPAN class="rem">// a XOR b : abs(a-b)</SPAN>
    <SPAN class="rem">// See intersect_shapes_aa for more comments</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_abs_diff_aa">sbool_xor_shapes_abs_diff_aa</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                                      Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                                      Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_aa">sbool_add_span_aa</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor1<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_aa">sbool_add_span_aa</A><SPAN class="op">&lt;</SPAN>Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor2<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_spans_aa">sbool_xor_spans_aa</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> 
                           Scanline2<SPAN class="op">,</SPAN> 
                           Scanline<SPAN class="op">,</SPAN> 
                           <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_formula_abs_diff">sbool_xor_formula_abs_diff</A><SPAN class="op">&gt;</SPAN> combine_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes">sbool_unite_shapes</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> 
                           add_functor1<SPAN class="op">,</SPAN> add_functor2<SPAN class="op">,</SPAN> combine_functor<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//--------------------------------------------------<A name="sbool_xor_shapes_bin"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_bin">sbool_xor_shapes_bin</A></SPAN>
    <SPAN class="rem">// Apply eXclusive OR to two binary scanline shapes (without anti-aliasing). </SPAN>
    <SPAN class="rem">// See intersect_shapes_aa for more comments</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_bin">sbool_xor_shapes_bin</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                              Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                              Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_bin">sbool_add_span_bin</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor1<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_bin">sbool_add_span_bin</A><SPAN class="op">&lt;</SPAN>Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor2<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_combine_spans_empty">sbool_combine_spans_empty</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> combine_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes">sbool_unite_shapes</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> 
                           add_functor1<SPAN class="op">,</SPAN> add_functor2<SPAN class="op">,</SPAN> combine_functor<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>






    <SPAN class="rem">//----------------------------------------------<A name="sbool_subtract_shapes_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes_aa">sbool_subtract_shapes_aa</A></SPAN>
    <SPAN class="rem">// Subtract shapes &quot;sg1-sg2&quot; with anti-aliasing</SPAN>
    <SPAN class="rem">// See intersect_shapes_aa for more comments</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes_aa">sbool_subtract_shapes_aa</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                                  Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                                  Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_aa">sbool_add_span_aa</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_spans_aa">sbool_subtract_spans_aa</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> combine_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes">sbool_subtract_shapes</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> 
                              add_functor<SPAN class="op">,</SPAN> combine_functor<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>





    <SPAN class="rem">//---------------------------------------------<A name="sbool_subtract_shapes_bin"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes_bin">sbool_subtract_shapes_bin</A></SPAN>
    <SPAN class="rem">// Subtract binary shapes &quot;sg1-sg2&quot; without anti-aliasing</SPAN>
    <SPAN class="rem">// See intersect_shapes_aa for more comments</SPAN>
    <SPAN class="rem">//----------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes_bin">sbool_subtract_shapes_bin</A><SPAN class="op">(</SPAN>ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                                   Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                                   Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_add_span_bin">sbool_add_span_bin</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> add_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_combine_spans_empty">sbool_combine_spans_empty</A><SPAN class="op">&lt;</SPAN>Scanline1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">,</SPAN> Scanline<SPAN class="op">&gt;</SPAN> combine_functor<SPAN class="op">;</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes">sbool_subtract_shapes</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">,</SPAN> 
                              add_functor<SPAN class="op">,</SPAN> combine_functor<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>






    <SPAN class="rem">//------------------------------------------------------------<A name="sbool_op_e"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_op_e">sbool_op_e</A></SPAN>
    <SPAN class="kw1">enum</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_op_e">sbool_op_e</A>
    <SPAN class="op">{</SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_or">sbool_or</A><SPAN class="op">,</SPAN>            <SPAN class="rem">//----<A name="sbool_or"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_or">sbool_or</A></SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_and">sbool_and</A><SPAN class="op">,</SPAN>           <SPAN class="rem">//----<A name="sbool_and"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_and">sbool_and</A></SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_xor">sbool_xor</A><SPAN class="op">,</SPAN>           <SPAN class="rem">//----<A name="sbool_xor"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_xor">sbool_xor</A></SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_saddle">sbool_xor_saddle</A><SPAN class="op">,</SPAN>    <SPAN class="rem">//----<A name="sbool_xor_saddle"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_xor_saddle">sbool_xor_saddle</A></SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_abs_diff">sbool_xor_abs_diff</A><SPAN class="op">,</SPAN>  <SPAN class="rem">//----<A name="sbool_xor_abs_diff"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_xor_abs_diff">sbool_xor_abs_diff</A></SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_a_minus_b">sbool_a_minus_b</A><SPAN class="op">,</SPAN>     <SPAN class="rem">//----<A name="sbool_a_minus_b"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_a_minus_b">sbool_a_minus_b</A></SPAN>
        <A href="agg_scanline_boolean_algebra.h.html#sbool_b_minus_a">sbool_b_minus_a</A>      <SPAN class="rem">//----<A name="sbool_b_minus_a"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_b_minus_a">sbool_b_minus_a</A></SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>






    <SPAN class="rem">//----------------------------------------------<A name="sbool_combine_shapes_bin"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_combine_shapes_bin">sbool_combine_shapes_bin</A></SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_combine_shapes_bin">sbool_combine_shapes_bin</A><SPAN class="op">(</SPAN><A href="agg_scanline_boolean_algebra.h.html#sbool_op_e">sbool_op_e</A> op<SPAN class="op">,</SPAN>
                                  ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                                  Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                                  Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN>op<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_or">sbool_or</A>          : <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes_bin">sbool_unite_shapes_bin</A>    <SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_and">sbool_and</A>         : <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_shapes_bin">sbool_intersect_shapes_bin</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor">sbool_xor</A>         :
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_saddle">sbool_xor_saddle</A>  : 
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_abs_diff">sbool_xor_abs_diff</A>: <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_bin">sbool_xor_shapes_bin</A>      <SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_a_minus_b">sbool_a_minus_b</A>   : <A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes_bin">sbool_subtract_shapes_bin</A> <SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_b_minus_a">sbool_b_minus_a</A>   : <A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes_bin">sbool_subtract_shapes_bin</A> <SPAN class="op">(</SPAN>sg2<SPAN class="op">,</SPAN> sg1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>




    <SPAN class="rem">//-----------------------------------------------<A name="sbool_combine_shapes_aa"><B></B></A><A href="agg_scanline_boolean_algebra.h.html#sbool_combine_shapes_aa">sbool_combine_shapes_aa</A></SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> ScanlineGen1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> ScanlineGen2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline1<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline2<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> 
             <SPAN class="kw1">class</SPAN> Renderer<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_combine_shapes_aa">sbool_combine_shapes_aa</A><SPAN class="op">(</SPAN><A href="agg_scanline_boolean_algebra.h.html#sbool_op_e">sbool_op_e</A> op<SPAN class="op">,</SPAN>
                                 ScanlineGen1<SPAN class="op">&amp;</SPAN> sg1<SPAN class="op">,</SPAN> ScanlineGen2<SPAN class="op">&amp;</SPAN> sg2<SPAN class="op">,</SPAN>
                                 Scanline1<SPAN class="op">&amp;</SPAN> sl1<SPAN class="op">,</SPAN> Scanline2<SPAN class="op">&amp;</SPAN> sl2<SPAN class="op">,</SPAN>
                                 Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN> Renderer<SPAN class="op">&amp;</SPAN> ren<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN>op<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_or">sbool_or</A>          : <A href="agg_scanline_boolean_algebra.h.html#sbool_unite_shapes_aa">sbool_unite_shapes_aa</A>       <SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_and">sbool_and</A>         : <A href="agg_scanline_boolean_algebra.h.html#sbool_intersect_shapes_aa">sbool_intersect_shapes_aa</A>   <SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor">sbool_xor</A>         : <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_aa">sbool_xor_shapes_aa</A>         <SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_saddle">sbool_xor_saddle</A>  : <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_saddle_aa">sbool_xor_shapes_saddle_aa</A>  <SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_abs_diff">sbool_xor_abs_diff</A>: <A href="agg_scanline_boolean_algebra.h.html#sbool_xor_shapes_abs_diff_aa">sbool_xor_shapes_abs_diff_aa</A><SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_a_minus_b">sbool_a_minus_b</A>   : <A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes_aa">sbool_subtract_shapes_aa</A>    <SPAN class="op">(</SPAN>sg1<SPAN class="op">,</SPAN> sg2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">case</SPAN> <A href="agg_scanline_boolean_algebra.h.html#sbool_b_minus_a">sbool_b_minus_a</A>   : <A href="agg_scanline_boolean_algebra.h.html#sbool_subtract_shapes_aa">sbool_subtract_shapes_aa</A>    <SPAN class="op">(</SPAN>sg2<SPAN class="op">,</SPAN> sg1<SPAN class="op">,</SPAN> sl2<SPAN class="op">,</SPAN> sl1<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>

<SPAN class="op">}</SPAN>


<SPAN class="kw2">#endif</SPAN>

</PRE></TD></TR></TABLE><FONT style="margin-left:1em"><I></I></FONT><TABLE width="640px" bgcolor="#583927" height="1px" border="0" cellspacing="0" cellpadding="0" style="margin:0px;"><TR><TD></TD></TR></TABLE>
<TABLE width="640px" border="0" cellspacing="0" cellpadding="0">
<TR><TD><CENTER><SPAN class="authors">
Copyright <SPAN class="larger">&#169;</SPAN> 2002-2006
<A href="../../mcseem/index.html"><B>Maxim Shemanarev</B></A>
</SPAN></CENTER></TD></TR>
<TR><TD><CENTER><SPAN class="authors">
Web Design and Programming
<A href="../../mcseem/index.html"><B>Maxim Shemanarev</B></A>
</SPAN></CENTER></TD></TR>
</TABLE>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
</HTML>
