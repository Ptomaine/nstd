<HTML><HEAD><TITLE>Anti-Grain Geometry - </TITLE>
<META http-equiv="Content-Type" content="text/html"/>
<LINK rel="stylesheet" type="text/css" href="../../agg.styles.css"/>
</HEAD>
<TABLE width="640px" border="0" cellspacing="0" cellpadding="0"><TR><TD><PRE><SPAN class="rem">//----------------------------------------------------------------------------</SPAN>
<SPAN class="rem">// Anti-Grain Geometry (AGG) - Version 2.5</SPAN>
<SPAN class="rem">// A high quality rendering engine for C++</SPAN>
<SPAN class="rem">// Copyright (C) 2002-2006 Maxim Shemanarev</SPAN>
<SPAN class="rem">// Contact: mcseem@antigrain.com</SPAN>
<SPAN class="rem">//          mcseemagg@yahoo.com</SPAN>
<SPAN class="rem">//          http://antigrain.com</SPAN>
<SPAN class="rem">// </SPAN>
<SPAN class="rem">// AGG is free software; you can redistribute it and/or</SPAN>
<SPAN class="rem">// modify it under the terms of the GNU General Public License</SPAN>
<SPAN class="rem">// as published by the Free Software Foundation; either version 2</SPAN>
<SPAN class="rem">// of the License, or (at your option) any later version.</SPAN>
<SPAN class="rem">// </SPAN>
<SPAN class="rem">// AGG is distributed in the hope that it will be useful,</SPAN>
<SPAN class="rem">// but WITHOUT ANY WARRANTY; without even the implied warranty of</SPAN>
<SPAN class="rem">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</SPAN>
<SPAN class="rem">// GNU General Public License for more details.</SPAN>
<SPAN class="rem">// </SPAN>
<SPAN class="rem">// You should have received a copy of the GNU General Public License</SPAN>
<SPAN class="rem">// along with AGG; if not, write to the Free Software</SPAN>
<SPAN class="rem">// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, </SPAN>
<SPAN class="rem">// MA 02110-1301, USA.</SPAN>
<SPAN class="rem">//----------------------------------------------------------------------------</SPAN>

<SPAN class="kw2">#include</SPAN> <SPAN class="op">&lt;</SPAN>stdio<SPAN class="op">.</SPAN>h<SPAN class="op">&gt;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="agg_font_win32_tt.h.html">agg_font_win32_tt.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../include/agg_bitset_iterator.h.html">agg_bitset_iterator.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../include/agg_renderer_scanline.h.html">agg_renderer_scanline.h</A>&quot;</SPAN>

<SPAN class="kw2">#ifdef</SPAN> AGG_WIN9X_COMPLIANT
<SPAN class="kw2">#define</SPAN> GetGlyphOutlineX GetGlyphOutline
<SPAN class="kw2">#else</SPAN>
<SPAN class="kw2">#define</SPAN> GetGlyphOutlineX GetGlyphOutlineW
<SPAN class="kw2">#endif</SPAN>

<SPAN class="kw1">namespace</SPAN> agg
<SPAN class="op">{</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------------</SPAN>
    <SPAN class="rem">//</SPAN>
    <SPAN class="rem">// This code implements the AUTODIN II polynomial</SPAN>
    <SPAN class="rem">// The variable corresponding to the macro argument &quot;crc&quot; should</SPAN>
    <SPAN class="rem">// be an unsigned long.</SPAN>
    <SPAN class="rem">// Oroginal code  by Spencer Garrett &lt;srg@quick.com&gt;</SPAN>
    <SPAN class="rem">//</SPAN>

    <SPAN class="rem">// generated using the AUTODIN II polynomial</SPAN>
    <SPAN class="rem">//   x^32 + x^26 + x^23 + x^22 + x^16 +</SPAN>
    <SPAN class="rem">//   x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x^1 + 1</SPAN>
    <SPAN class="rem">//</SPAN>
    <SPAN class="rem">//------------------------------------------------------------------------------</SPAN>

    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">const</SPAN> <SPAN class="kw1">unsigned</SPAN> crc32tab<SPAN class="op">[</SPAN><SPAN class="num">256</SPAN><SPAN class="op">]</SPAN> <SPAN class="op">=</SPAN> 
    <SPAN class="op">{</SPAN>
       <SPAN class="num">0x00000000</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x77073096</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xee0e612c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x990951ba</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x076dc419</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x706af48f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe963a535</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9e6495a3</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x0edb8832</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x79dcb8a4</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe0d5e91e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x97d2d988</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x09b64c2b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x7eb17cbd</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe7b82d07</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x90bf1d91</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x1db71064</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x6ab020f2</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf3b97148</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x84be41de</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x1adad47d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x6ddde4eb</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf4d4b551</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x83d385c7</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x136c9856</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x646ba8c0</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xfd62f97a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8a65c9ec</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x14015c4f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x63066cd9</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xfa0f3d63</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8d080df5</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x3b6e20c8</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4c69105e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd56041e4</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa2677172</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x3c03e4d1</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4b04d447</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd20d85fd</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa50ab56b</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x35b5a8fa</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x42b2986c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xdbbbc9d6</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xacbcf940</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x32d86ce3</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x45df5c75</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xdcd60dcf</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xabd13d59</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x26d930ac</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x51de003a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc8d75180</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xbfd06116</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x21b4f4b5</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x56b3c423</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xcfba9599</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb8bda50f</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x2802b89e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5f058808</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc60cd9b2</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb10be924</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x2f6f7c87</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x58684c11</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc1611dab</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb6662d3d</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x76dc4190</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x01db7106</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x98d220bc</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xefd5102a</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x71b18589</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x06b6b51f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9fbfe4a5</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe8b8d433</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x7807c9a2</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x0f00f934</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9609a88e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe10e9818</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x7f6a0dbb</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x086d3d2d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x91646c97</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe6635c01</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x6b6b51f4</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x1c6c6162</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x856530d8</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf262004e</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x6c0695ed</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x1b01a57b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8208f4c1</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf50fc457</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x65b0d9c6</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x12b7e950</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8bbeb8ea</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xfcb9887c</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x62dd1ddf</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x15da2d49</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8cd37cf3</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xfbd44c65</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x4db26158</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x3ab551ce</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa3bc0074</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd4bb30e2</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x4adfa541</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x3dd895d7</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa4d1c46d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd3d6f4fb</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x4369e96a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x346ed9fc</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xad678846</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xda60b8d0</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x44042d73</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x33031de5</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xaa0a4c5f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xdd0d7cc9</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x5005713c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x270241aa</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xbe0b1010</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc90c2086</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x5768b525</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x206f85b3</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb966d409</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xce61e49f</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x5edef90e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x29d9c998</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb0d09822</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc7d7a8b4</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x59b33d17</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x2eb40d81</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb7bd5c3b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc0ba6cad</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xedb88320</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9abfb3b6</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x03b6e20c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x74b1d29a</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xead54739</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9dd277af</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x04db2615</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x73dc1683</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xe3630b12</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x94643b84</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x0d6d6a3e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x7a6a5aa8</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xe40ecf0b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x9309ff9d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x0a00ae27</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x7d079eb1</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xf00f9344</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8708a3d2</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x1e01f268</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x6906c2fe</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xf762575d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x806567cb</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x196c3671</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x6e6b06e7</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xfed41b76</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x89d32be0</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x10da7a5a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x67dd4acc</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xf9b9df6f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x8ebeeff9</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x17b7be43</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x60b08ed5</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xd6d6a3e8</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa1d1937e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x38d8c2c4</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4fdff252</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xd1bb67f1</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa6bc5767</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x3fb506dd</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x48b2364b</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xd80d2bda</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xaf0a1b4c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x36034af6</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x41047a60</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xdf60efc3</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xa867df55</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x316e8eef</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4669be79</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xcb61b38c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xbc66831a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x256fd2a0</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5268e236</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xcc0c7795</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xbb0b4703</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x220216b9</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5505262f</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xc5ba3bbe</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb2bd0b28</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x2bb45a92</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5cb36a04</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xc2d7ffa7</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xb5d0cf31</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x2cd99e8b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5bdeae1d</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x9b64c2b0</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xec63f226</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x756aa39c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x026d930a</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x9c0906a9</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xeb0e363f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x72076785</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x05005713</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x95bf4a82</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe2b87a14</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x7bb12bae</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x0cb61b38</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x92d28e9b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xe5d5be0d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x7cdcefb7</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x0bdbdf21</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x86d3d2d4</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf1d4e242</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x68ddb3f8</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x1fda836e</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x81be16cd</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf6b9265b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x6fb077e1</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x18b74777</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x88085ae6</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xff0f6a70</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x66063bca</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x11010b5c</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0x8f659eff</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xf862ae69</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x616bffd3</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x166ccf45</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xa00ae278</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd70dd2ee</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4e048354</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x3903b3c2</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xa7672661</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd06016f7</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x4969474d</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x3e6e77db</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xaed16a4a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xd9d65adc</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x40df0b66</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x37d83bf0</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xa9bcae53</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xdebb9ec5</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x47b2cf7f</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x30b5ffe9</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xbdbdf21c</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xcabac28a</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x53b39330</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x24b4a3a6</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xbad03605</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xcdd70693</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x54de5729</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x23d967bf</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xb3667a2e</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc4614ab8</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5d681b02</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x2a6f2b94</SPAN><SPAN class="op">,</SPAN>
       <SPAN class="num">0xb40bbe37</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0xc30c8ea1</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x5a05df1b</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0x2d02ef8d</SPAN><SPAN class="op">,</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">unsigned</SPAN> calc_crc32<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">unsigned</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> buf<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> size<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">unsigned</SPAN> crc <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN><SPAN class="op">)</SPAN>~<SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">const</SPAN> <SPAN class="kw1">unsigned</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> p<SPAN class="op">;</SPAN>
        <SPAN class="kw1">unsigned</SPAN> len <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> 
        <SPAN class="kw1">unsigned</SPAN> nr <SPAN class="op">=</SPAN> size<SPAN class="op">;</SPAN>

        <SPAN class="kw1">for</SPAN> <SPAN class="op">(</SPAN>len <SPAN class="op">+=</SPAN> nr<SPAN class="op">,</SPAN> p <SPAN class="op">=</SPAN> buf<SPAN class="op">;</SPAN> nr<SPAN class="op">--</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">++</SPAN>p<SPAN class="op">)</SPAN> 
        <SPAN class="op">{</SPAN>
            crc <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>crc <SPAN class="op">&gt;&gt;</SPAN> <SPAN class="num">8</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">^</SPAN> crc32tab<SPAN class="op">[</SPAN><SPAN class="op">(</SPAN>crc <SPAN class="op">^</SPAN> <SPAN class="op">*</SPAN>p<SPAN class="op">)</SPAN> <SPAN class="op">&amp;</SPAN> <SPAN class="num">0xff</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> ~crc<SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">inline</SPAN> FIXED dbl_to_fx<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> d<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">int</SPAN> l<SPAN class="op">;</SPAN>
        l <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>d <SPAN class="op">*</SPAN> <SPAN class="num">65536</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>FIXED<SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">&amp;</SPAN>l<SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">inline</SPAN> <SPAN class="kw1">int</SPAN> dbl_to_plain_fx<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> d<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>d <SPAN class="op">*</SPAN> <SPAN class="num">65536</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">inline</SPAN> FIXED negate_fx<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> FIXED<SPAN class="op">&amp;</SPAN> fx<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">int</SPAN> l <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN><SPAN class="op">(</SPAN><SPAN class="op">*</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>fx<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN>FIXED<SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">&amp;</SPAN>l<SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">inline</SPAN> <SPAN class="kw1">double</SPAN> fx_to_dbl<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> FIXED<SPAN class="op">&amp;</SPAN> p<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">double</SPAN><SPAN class="op">(</SPAN>p<SPAN class="op">.</SPAN>value<SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="kw1">double</SPAN><SPAN class="op">(</SPAN>p<SPAN class="op">.</SPAN>fract<SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> <SPAN class="op">(</SPAN><SPAN class="num">1</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN> <SPAN class="op">/</SPAN> <SPAN class="num">65536</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">inline</SPAN> <SPAN class="kw1">int</SPAN> fx_to_plain_int<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> FIXED<SPAN class="op">&amp;</SPAN> fx<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>fx<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">inline</SPAN> <SPAN class="kw1">int</SPAN> fx_to_int26p6<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> FIXED<SPAN class="op">&amp;</SPAN> p<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>p<SPAN class="op">.</SPAN>value<SPAN class="op">)</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <SPAN class="num">6</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>p<SPAN class="op">.</SPAN>fract<SPAN class="op">)</SPAN> <SPAN class="op">&gt;&gt;</SPAN> <SPAN class="num">10</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">inline</SPAN> <SPAN class="kw1">int</SPAN> dbl_to_int26p6<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> p<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>p <SPAN class="op">*</SPAN> <SPAN class="num">64</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">5</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> <SPAN class="kw1">class</SPAN> ScanlineStorage<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> decompose_win32_glyph_bitmap_mono<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> gbuf<SPAN class="op">,</SPAN> 
                                           <SPAN class="kw1">int</SPAN> w<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> h<SPAN class="op">,</SPAN>
                                           <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> y<SPAN class="op">,</SPAN>
                                           <SPAN class="kw1">bool</SPAN> flip_y<SPAN class="op">,</SPAN>
                                           Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN>
                                           ScanlineStorage<SPAN class="op">&amp;</SPAN> storage<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">int</SPAN> i<SPAN class="op">;</SPAN>
        <SPAN class="kw1">int</SPAN> pitch <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">(</SPAN>w <SPAN class="op">+</SPAN> <SPAN class="num">31</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&gt;&gt;</SPAN> <SPAN class="num">5</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">const</SPAN> <A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN> buf <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN>gbuf<SPAN class="op">;</SPAN>
        sl<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> x <SPAN class="op">+</SPAN> w<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        storage<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            buf <SPAN class="op">+=</SPAN> pitch <SPAN class="op">*</SPAN> <SPAN class="op">(</SPAN>h <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            y <SPAN class="op">+=</SPAN> h<SPAN class="op">;</SPAN>
            pitch <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>pitch<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> h<SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            sl<SPAN class="op">.</SPAN>reset_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            bitset_iterator bits<SPAN class="op">(</SPAN>buf<SPAN class="op">,</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> j<SPAN class="op">;</SPAN>
            <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>j <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> j <SPAN class="op">&lt;</SPAN> w<SPAN class="op">;</SPAN> j<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>bits<SPAN class="op">.</SPAN>bit<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x <SPAN class="op">+</SPAN> j<SPAN class="op">,</SPAN> <A href="../include/agg_basics.h.html#cover_full">cover_full</A><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">++</SPAN>bits<SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            buf <SPAN class="op">+=</SPAN> pitch<SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>sl<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                sl<SPAN class="op">.</SPAN>finalize<SPAN class="op">(</SPAN>y <SPAN class="op">-</SPAN> i <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                storage<SPAN class="op">.</SPAN>render<SPAN class="op">(</SPAN>sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Rasterizer<SPAN class="op">,</SPAN> <SPAN class="kw1">class</SPAN> Scanline<SPAN class="op">,</SPAN> <SPAN class="kw1">class</SPAN> ScanlineStorage<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">void</SPAN> decompose_win32_glyph_bitmap_gray8<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> gbuf<SPAN class="op">,</SPAN> 
                                            <SPAN class="kw1">int</SPAN> w<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> h<SPAN class="op">,</SPAN>
                                            <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> y<SPAN class="op">,</SPAN>
                                            <SPAN class="kw1">bool</SPAN> flip_y<SPAN class="op">,</SPAN>
                                            Rasterizer<SPAN class="op">&amp;</SPAN> ras<SPAN class="op">,</SPAN>
                                            Scanline<SPAN class="op">&amp;</SPAN> sl<SPAN class="op">,</SPAN>
                                            ScanlineStorage<SPAN class="op">&amp;</SPAN> storage<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">int</SPAN> i<SPAN class="op">,</SPAN> j<SPAN class="op">;</SPAN>
        <SPAN class="kw1">int</SPAN> pitch <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">(</SPAN>w <SPAN class="op">+</SPAN> <SPAN class="num">3</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&gt;&gt;</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&lt;&lt;</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">const</SPAN> <A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN> buf <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN>gbuf<SPAN class="op">;</SPAN>
        sl<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> x <SPAN class="op">+</SPAN> w<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        storage<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            buf <SPAN class="op">+=</SPAN> pitch <SPAN class="op">*</SPAN> <SPAN class="op">(</SPAN>h <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            y <SPAN class="op">+=</SPAN> h<SPAN class="op">;</SPAN>
            pitch <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>pitch<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> h<SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            sl<SPAN class="op">.</SPAN>reset_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> <A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN> p <SPAN class="op">=</SPAN> buf<SPAN class="op">;</SPAN>
            <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>j <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> j <SPAN class="op">&lt;</SPAN> w<SPAN class="op">;</SPAN> j<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">*</SPAN>p<SPAN class="op">)</SPAN> 
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">unsigned</SPAN> v <SPAN class="op">=</SPAN> <SPAN class="op">*</SPAN>p<SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>v <SPAN class="op">==</SPAN> <SPAN class="num">64</SPAN><SPAN class="op">)</SPAN> v <SPAN class="op">=</SPAN> <SPAN class="num">255</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">else</SPAN> v <SPAN class="op">&lt;&lt;=</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>
                    sl<SPAN class="op">.</SPAN>add_cell<SPAN class="op">(</SPAN>x <SPAN class="op">+</SPAN> j<SPAN class="op">,</SPAN> ras<SPAN class="op">.</SPAN>apply_gamma<SPAN class="op">(</SPAN>v<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="op">++</SPAN>p<SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            buf <SPAN class="op">+=</SPAN> pitch<SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>sl<SPAN class="op">.</SPAN>num_spans<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                sl<SPAN class="op">.</SPAN>finalize<SPAN class="op">(</SPAN>y <SPAN class="op">-</SPAN> i <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                storage<SPAN class="op">.</SPAN>render<SPAN class="op">(</SPAN>sl<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> PathStorage<SPAN class="op">&gt;</SPAN>
    <SPAN class="kw1">bool</SPAN> decompose_win32_glyph_outline<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> gbuf<SPAN class="op">,</SPAN>
                                       <SPAN class="kw1">unsigned</SPAN> total_size<SPAN class="op">,</SPAN>
                                       <SPAN class="kw1">bool</SPAN> flip_y<SPAN class="op">,</SPAN> 
                                       <SPAN class="kw1">const</SPAN> <A href="../include/agg_trans_affine.h.html#trans_affine">trans_affine</A><SPAN class="op">&amp;</SPAN> mtx<SPAN class="op">,</SPAN>
                                       PathStorage<SPAN class="op">&amp;</SPAN> path<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> cur_glyph <SPAN class="op">=</SPAN> gbuf<SPAN class="op">;</SPAN>
        <SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> end_glyph <SPAN class="op">=</SPAN> gbuf <SPAN class="op">+</SPAN> total_size<SPAN class="op">;</SPAN>
        <SPAN class="kw1">double</SPAN> x<SPAN class="op">,</SPAN> y<SPAN class="op">;</SPAN>
        <SPAN class="kw1">typedef</SPAN> <SPAN class="kw1">typename</SPAN> PathStorage::value_type value_type<SPAN class="op">;</SPAN>
        
        <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN>cur_glyph <SPAN class="op">&lt;</SPAN> end_glyph<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">const</SPAN> TTPOLYGONHEADER<SPAN class="op">*</SPAN> th <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>TTPOLYGONHEADER<SPAN class="op">*</SPAN><SPAN class="op">)</SPAN>cur_glyph<SPAN class="op">;</SPAN>
            
            <SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> end_poly <SPAN class="op">=</SPAN> cur_glyph <SPAN class="op">+</SPAN> th<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>cb<SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> cur_poly <SPAN class="op">=</SPAN> cur_glyph <SPAN class="op">+</SPAN> <SPAN class="kw1">sizeof</SPAN><SPAN class="op">(</SPAN>TTPOLYGONHEADER<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

            x <SPAN class="op">=</SPAN> fx_to_dbl<SPAN class="op">(</SPAN>th<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>pfxStart<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            y <SPAN class="op">=</SPAN> fx_to_dbl<SPAN class="op">(</SPAN>th<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>pfxStart<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN> y <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y<SPAN class="op">;</SPAN>
            mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            path<SPAN class="op">.</SPAN>move_to<SPAN class="op">(</SPAN>value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                         value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN>cur_poly <SPAN class="op">&lt;</SPAN> end_poly<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">const</SPAN> TTPOLYCURVE<SPAN class="op">*</SPAN> pc <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> TTPOLYCURVE<SPAN class="op">*</SPAN><SPAN class="op">)</SPAN>cur_poly<SPAN class="op">;</SPAN>
                
                <SPAN class="kw1">if</SPAN> <SPAN class="op">(</SPAN>pc<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>wType <SPAN class="op">==</SPAN> TT_PRIM_LINE<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">int</SPAN> i<SPAN class="op">;</SPAN>
                    <SPAN class="kw1">for</SPAN> <SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> pc<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>cpfx<SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        x <SPAN class="op">=</SPAN> fx_to_dbl<SPAN class="op">(</SPAN>pc<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>apfx<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        y <SPAN class="op">=</SPAN> fx_to_dbl<SPAN class="op">(</SPAN>pc<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>apfx<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN> y <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y<SPAN class="op">;</SPAN>
                        mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        path<SPAN class="op">.</SPAN>line_to<SPAN class="op">(</SPAN>value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                     value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                <SPAN class="op">}</SPAN>
                
                <SPAN class="kw1">if</SPAN> <SPAN class="op">(</SPAN>pc<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>wType <SPAN class="op">==</SPAN> TT_PRIM_QSPLINE<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">int</SPAN> u<SPAN class="op">;</SPAN>
                    <SPAN class="kw1">for</SPAN> <SPAN class="op">(</SPAN>u <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> u <SPAN class="op">&lt;</SPAN> pc<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>cpfx <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> u<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>  <SPAN class="rem">// Walk through points in spline</SPAN>
                    <SPAN class="op">{</SPAN>
                        POINTFX pnt_b <SPAN class="op">=</SPAN> pc<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>apfx<SPAN class="op">[</SPAN>u<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>    <SPAN class="rem">// B is always the current point</SPAN>
                        POINTFX pnt_c <SPAN class="op">=</SPAN> pc<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>apfx<SPAN class="op">[</SPAN>u<SPAN class="op">+</SPAN><SPAN class="num">1</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                        
                        <SPAN class="kw1">if</SPAN> <SPAN class="op">(</SPAN>u <SPAN class="op">&lt;</SPAN> pc<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>cpfx <SPAN class="op">-</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">)</SPAN>           <SPAN class="rem">// If not on last spline, compute C</SPAN>
                        <SPAN class="op">{</SPAN>
                            <SPAN class="rem">// midpoint (x,y)</SPAN>
                            <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">&amp;</SPAN>pnt_c<SPAN class="op">.</SPAN>x <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">*</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">&amp;</SPAN>pnt_b<SPAN class="op">.</SPAN>x <SPAN class="op">+</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">&amp;</SPAN>pnt_c<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>
                            <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">&amp;</SPAN>pnt_c<SPAN class="op">.</SPAN>y <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN><SPAN class="op">*</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">&amp;</SPAN>pnt_b<SPAN class="op">.</SPAN>y <SPAN class="op">+</SPAN> <SPAN class="op">*</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">&amp;</SPAN>pnt_c<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="op">}</SPAN>
                        
                        <SPAN class="kw1">double</SPAN> x2<SPAN class="op">,</SPAN> y2<SPAN class="op">;</SPAN>
                        x  <SPAN class="op">=</SPAN> fx_to_dbl<SPAN class="op">(</SPAN>pnt_b<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        y  <SPAN class="op">=</SPAN> fx_to_dbl<SPAN class="op">(</SPAN>pnt_b<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        x2 <SPAN class="op">=</SPAN> fx_to_dbl<SPAN class="op">(</SPAN>pnt_c<SPAN class="op">.</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        y2 <SPAN class="op">=</SPAN> fx_to_dbl<SPAN class="op">(</SPAN>pnt_c<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flip_y<SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> y <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y<SPAN class="op">;</SPAN> y2 <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>y2<SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
                        mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x<SPAN class="op">,</SPAN>  <SPAN class="op">&amp;</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        mtx<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>x2<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        path<SPAN class="op">.</SPAN><A href="../include/agg_curves.h.html#curve3">curve3</A><SPAN class="op">(</SPAN>value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                    value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                                    value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                                    value_type<SPAN class="op">(</SPAN>dbl_to_int26p6<SPAN class="op">(</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                <SPAN class="op">}</SPAN>
                cur_poly <SPAN class="op">+=</SPAN> <SPAN class="kw1">sizeof</SPAN><SPAN class="op">(</SPAN>WORD<SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> <SPAN class="num">2</SPAN> <SPAN class="op">+</SPAN> <SPAN class="kw1">sizeof</SPAN><SPAN class="op">(</SPAN>POINTFX<SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> pc<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>cpfx<SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            cur_glyph <SPAN class="op">+=</SPAN> th<SPAN class="op">-</SPAN><SPAN class="op">&gt;</SPAN>cb<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>




    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <A href="agg_font_win32_tt.h.html#font_engine_win32_tt_base">font_engine_win32_tt_base</A>::~<A href="agg_font_win32_tt.h.html#font_engine_win32_tt_base">font_engine_win32_tt_base</A><SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_kerning_pairs<SPAN class="op">;</SPAN>
        <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_gbuf<SPAN class="op">;</SPAN>
        <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_signature<SPAN class="op">;</SPAN>
        <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_typeface<SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_dc <SPAN class="op">&amp;&amp;</SPAN> m_old_font<SPAN class="op">)</SPAN> ::SelectObject<SPAN class="op">(</SPAN>m_dc<SPAN class="op">,</SPAN> m_old_font<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">;</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> m_num_fonts<SPAN class="op">;</SPAN> <SPAN class="op">++</SPAN>i<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_font_names<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
            ::DeleteObject<SPAN class="op">(</SPAN>m_fonts<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_font_names<SPAN class="op">;</SPAN>
        <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_fonts<SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    font_engine_win32_tt_base::<A href="agg_font_win32_tt.h.html#font_engine_win32_tt_base">font_engine_win32_tt_base</A><SPAN class="op">(</SPAN><SPAN class="kw1">bool</SPAN> flag32<SPAN class="op">,</SPAN> 
                                                         HDC dc<SPAN class="op">,</SPAN> 
                                                         <SPAN class="kw1">unsigned</SPAN> max_fonts<SPAN class="op">)</SPAN> :
        m_flag32<SPAN class="op">(</SPAN>flag32<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_dc<SPAN class="op">(</SPAN>dc<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_old_font<SPAN class="op">(</SPAN>m_dc ? <SPAN class="op">(</SPAN>HFONT<SPAN class="op">)</SPAN>::GetCurrentObject<SPAN class="op">(</SPAN>m_dc<SPAN class="op">,</SPAN> OBJ_FONT<SPAN class="op">)</SPAN> : <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_fonts<SPAN class="op">(</SPAN><SPAN class="kw1">new</SPAN> HFONT <SPAN class="op">[</SPAN>max_fonts<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_num_fonts<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_max_fonts<SPAN class="op">(</SPAN>max_fonts<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_font_names<SPAN class="op">(</SPAN><SPAN class="kw1">new</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> <SPAN class="op">[</SPAN>max_fonts<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_cur_font<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>

        m_change_stamp<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_typeface<SPAN class="op">(</SPAN><SPAN class="kw1">new</SPAN> <SPAN class="kw1">char</SPAN> <SPAN class="op">[</SPAN><SPAN class="num">256</SPAN><SPAN class="op">-</SPAN><SPAN class="num">16</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_typeface_len<SPAN class="op">(</SPAN><SPAN class="num">256</SPAN><SPAN class="op">-</SPAN><SPAN class="num">16</SPAN><SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_signature<SPAN class="op">(</SPAN><SPAN class="kw1">new</SPAN> <SPAN class="kw1">char</SPAN> <SPAN class="op">[</SPAN><SPAN class="num">256</SPAN><SPAN class="op">+</SPAN><SPAN class="num">256</SPAN><SPAN class="op">-</SPAN><SPAN class="num">16</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_height<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_width<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_weight<SPAN class="op">(</SPAN>FW_REGULAR<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_italic<SPAN class="op">(</SPAN><SPAN class="kw1">false</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_char_set<SPAN class="op">(</SPAN>DEFAULT_CHARSET<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_pitch_and_family<SPAN class="op">(</SPAN>FF_DONTCARE<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_hinting<SPAN class="op">(</SPAN><SPAN class="kw1">true</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_flip_y<SPAN class="op">(</SPAN><SPAN class="kw1">false</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_font_created<SPAN class="op">(</SPAN><SPAN class="kw1">false</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_resolution<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_glyph_rendering<SPAN class="op">(</SPAN>glyph_ren_native_gray8<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_glyph_index<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_data_size<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_data_type<SPAN class="op">(</SPAN>glyph_data_invalid<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_bounds<SPAN class="op">(</SPAN><SPAN class="num">1</SPAN><SPAN class="op">,</SPAN><SPAN class="num">1</SPAN><SPAN class="op">,</SPAN><SPAN class="num">0</SPAN><SPAN class="op">,</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_advance_x<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_advance_y<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_gbuf<SPAN class="op">(</SPAN><SPAN class="kw1">new</SPAN> <SPAN class="kw1">char</SPAN> <SPAN class="op">[</SPAN>buf_size<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_kerning_pairs<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_num_kerning_pairs<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_max_kerning_pairs<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>

        m_path16<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_path32<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_curves16<SPAN class="op">(</SPAN>m_path16<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_curves32<SPAN class="op">(</SPAN>m_path32<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_scanline_aa<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_scanline_bin<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_scanlines_aa<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_scanlines_bin<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_rasterizer<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        m_curves16<SPAN class="op">.</SPAN>approximation_scale<SPAN class="op">(</SPAN><SPAN class="num">4</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        m_curves32<SPAN class="op">.</SPAN>approximation_scale<SPAN class="op">(</SPAN><SPAN class="num">4</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        memset<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>m_matrix<SPAN class="op">,</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">,</SPAN> <SPAN class="kw1">sizeof</SPAN><SPAN class="op">(</SPAN>m_matrix<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        m_matrix<SPAN class="op">.</SPAN>eM11<SPAN class="op">.</SPAN>value <SPAN class="op">=</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
        m_matrix<SPAN class="op">.</SPAN>eM22<SPAN class="op">.</SPAN>value <SPAN class="op">=</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">int</SPAN> font_engine_win32_tt_base::find_font<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> name<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">;</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> m_num_fonts<SPAN class="op">;</SPAN> <SPAN class="op">++</SPAN>i<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>strcmp<SPAN class="op">(</SPAN>name<SPAN class="op">,</SPAN> m_font_names<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN> i<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">bool</SPAN> font_engine_win32_tt_base::create_font<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> typeface_<SPAN class="op">,</SPAN> 
                                                glyph_rendering ren_type<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_dc<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">unsigned</SPAN> len <SPAN class="op">=</SPAN> strlen<SPAN class="op">(</SPAN>typeface_<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>len <SPAN class="op">&gt;</SPAN> m_typeface_len<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_signature<SPAN class="op">;</SPAN>
                <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_typeface<SPAN class="op">;</SPAN>
                m_typeface  <SPAN class="op">=</SPAN> <SPAN class="kw1">new</SPAN> <SPAN class="kw1">char</SPAN> <SPAN class="op">[</SPAN>len <SPAN class="op">+</SPAN> <SPAN class="num">32</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                m_signature <SPAN class="op">=</SPAN> <SPAN class="kw1">new</SPAN> <SPAN class="kw1">char</SPAN> <SPAN class="op">[</SPAN>len <SPAN class="op">+</SPAN> <SPAN class="num">32</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">256</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                m_typeface_len <SPAN class="op">=</SPAN> len <SPAN class="op">+</SPAN> <SPAN class="num">32</SPAN> <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            strcpy<SPAN class="op">(</SPAN>m_typeface<SPAN class="op">,</SPAN> typeface_<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">int</SPAN> h <SPAN class="op">=</SPAN> m_height<SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> w <SPAN class="op">=</SPAN> m_width<SPAN class="op">;</SPAN>

            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_resolution<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                h <SPAN class="op">=</SPAN> ::MulDiv<SPAN class="op">(</SPAN>m_height<SPAN class="op">,</SPAN> m_resolution<SPAN class="op">,</SPAN> <SPAN class="num">72</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                w <SPAN class="op">=</SPAN> ::MulDiv<SPAN class="op">(</SPAN>m_width<SPAN class="op">,</SPAN>  m_resolution<SPAN class="op">,</SPAN> <SPAN class="num">72</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            m_glyph_rendering <SPAN class="op">=</SPAN> ren_type<SPAN class="op">;</SPAN>
            update_signature<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> idx <SPAN class="op">=</SPAN> find_font<SPAN class="op">(</SPAN>m_signature<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>idx <SPAN class="op">&gt;=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                m_cur_font <SPAN class="op">=</SPAN> m_fonts<SPAN class="op">[</SPAN>idx<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                ::SelectObject<SPAN class="op">(</SPAN>m_dc<SPAN class="op">,</SPAN> m_cur_font<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_num_kerning_pairs <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="kw1">else</SPAN>
            <SPAN class="op">{</SPAN>
                m_cur_font <SPAN class="op">=</SPAN> ::CreateFont<SPAN class="op">(</SPAN><SPAN class="op">-</SPAN>h<SPAN class="op">,</SPAN>                     <SPAN class="rem">// height of font</SPAN>
                                          w<SPAN class="op">,</SPAN>                      <SPAN class="rem">// average character width</SPAN>
                                          <SPAN class="num">0</SPAN><SPAN class="op">,</SPAN>                      <SPAN class="rem">// angle of escapement</SPAN>
                                          <SPAN class="num">0</SPAN><SPAN class="op">,</SPAN>                      <SPAN class="rem">// base-line orientation angle</SPAN>
                                          m_weight<SPAN class="op">,</SPAN>               <SPAN class="rem">// font weight</SPAN>
                                          m_italic<SPAN class="op">,</SPAN>               <SPAN class="rem">// italic attribute option</SPAN>
                                          <SPAN class="num">0</SPAN><SPAN class="op">,</SPAN>                      <SPAN class="rem">// underline attribute option</SPAN>
                                          <SPAN class="num">0</SPAN><SPAN class="op">,</SPAN>                      <SPAN class="rem">// strikeout attribute option</SPAN>
                                          m_char_set<SPAN class="op">,</SPAN>             <SPAN class="rem">// character set identifier</SPAN>
                                          OUT_DEFAULT_PRECIS<SPAN class="op">,</SPAN>     <SPAN class="rem">// output precision</SPAN>
                                          CLIP_DEFAULT_PRECIS<SPAN class="op">,</SPAN>    <SPAN class="rem">// clipping precision</SPAN>
                                          ANTIALIASED_QUALITY<SPAN class="op">,</SPAN>    <SPAN class="rem">// output quality</SPAN>
                                          m_pitch_and_family<SPAN class="op">,</SPAN>     <SPAN class="rem">// pitch and family</SPAN>
                                          m_typeface<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>            <SPAN class="rem">// typeface name</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_cur_font<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_num_fonts <SPAN class="op">&gt;=</SPAN> m_max_fonts<SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        <SPAN class="kw1">delete</SPAN> <SPAN class="op">[</SPAN><SPAN class="op">]</SPAN> m_font_names<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_old_font<SPAN class="op">)</SPAN> ::SelectObject<SPAN class="op">(</SPAN>m_dc<SPAN class="op">,</SPAN> m_old_font<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        ::DeleteObject<SPAN class="op">(</SPAN>m_fonts<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        memcpy<SPAN class="op">(</SPAN>m_fonts<SPAN class="op">,</SPAN> 
                               m_fonts <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN> 
                               <SPAN class="op">(</SPAN>m_max_fonts <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> <SPAN class="kw1">sizeof</SPAN><SPAN class="op">(</SPAN>HFONT<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        memcpy<SPAN class="op">(</SPAN>m_font_names<SPAN class="op">,</SPAN> 
                               m_font_names <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN> 
                               <SPAN class="op">(</SPAN>m_max_fonts <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> <SPAN class="kw1">sizeof</SPAN><SPAN class="op">(</SPAN><SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_num_fonts <SPAN class="op">=</SPAN> m_max_fonts <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>

                    update_signature<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_font_names<SPAN class="op">[</SPAN>m_num_fonts<SPAN class="op">]</SPAN> <SPAN class="op">=</SPAN> <SPAN class="kw1">new</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">[</SPAN>strlen<SPAN class="op">(</SPAN>m_signature<SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                    strcpy<SPAN class="op">(</SPAN>m_font_names<SPAN class="op">[</SPAN>m_num_fonts<SPAN class="op">]</SPAN><SPAN class="op">,</SPAN> m_signature<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_fonts<SPAN class="op">[</SPAN>m_num_fonts<SPAN class="op">]</SPAN> <SPAN class="op">=</SPAN> m_cur_font<SPAN class="op">;</SPAN>
                    <SPAN class="op">++</SPAN>m_num_fonts<SPAN class="op">;</SPAN>
                    ::SelectObject<SPAN class="op">(</SPAN>m_dc<SPAN class="op">,</SPAN> m_cur_font<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_num_kerning_pairs <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>





    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">bool</SPAN> font_engine_win32_tt_base::create_font<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> typeface_<SPAN class="op">,</SPAN> 
                                                glyph_rendering ren_type<SPAN class="op">,</SPAN>
                                                <SPAN class="kw1">double</SPAN> height_<SPAN class="op">,</SPAN>
                                                <SPAN class="kw1">double</SPAN> width_<SPAN class="op">,</SPAN>
                                                <SPAN class="kw1">int</SPAN> weight_<SPAN class="op">,</SPAN>
                                                <SPAN class="kw1">bool</SPAN> italic_<SPAN class="op">,</SPAN>
                                                DWORD char_set_<SPAN class="op">,</SPAN>
                                                DWORD pitch_and_family_<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        height<SPAN class="op">(</SPAN>height_<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        width<SPAN class="op">(</SPAN>width_<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        weight<SPAN class="op">(</SPAN>weight_<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        italic<SPAN class="op">(</SPAN>italic_<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        char_set<SPAN class="op">(</SPAN>char_set_<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        pitch_and_family<SPAN class="op">(</SPAN>pitch_and_family_<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">return</SPAN> create_font<SPAN class="op">(</SPAN>typeface_<SPAN class="op">,</SPAN> ren_type<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>




    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">void</SPAN> font_engine_win32_tt_base::update_signature<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        m_signature<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN> <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_dc <SPAN class="op">&amp;&amp;</SPAN> m_cur_font<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">unsigned</SPAN> gamma_hash <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_native_gray8 <SPAN class="op">||</SPAN>
               m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_mono <SPAN class="op">||</SPAN> 
               m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_gray8<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">unsigned</SPAN> <SPAN class="kw1">char</SPAN> gamma_table<SPAN class="op">[</SPAN><A href="../include/agg_rasterizer_scanline_aa.h.html#rasterizer_scanline_aa">rasterizer_scanline_aa</A><SPAN class="op">&lt;</SPAN><SPAN class="op">&gt;</SPAN>::aa_scale<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">;</SPAN>
                <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> <A href="../include/agg_rasterizer_scanline_aa.h.html#rasterizer_scanline_aa">rasterizer_scanline_aa</A><SPAN class="op">&lt;</SPAN><SPAN class="op">&gt;</SPAN>::aa_scale<SPAN class="op">;</SPAN> <SPAN class="op">++</SPAN>i<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    gamma_table<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN> <SPAN class="op">=</SPAN> m_rasterizer<SPAN class="op">.</SPAN>apply_gamma<SPAN class="op">(</SPAN>i<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                gamma_hash <SPAN class="op">=</SPAN> calc_crc32<SPAN class="op">(</SPAN>gamma_table<SPAN class="op">,</SPAN> <SPAN class="kw1">sizeof</SPAN><SPAN class="op">(</SPAN>gamma_table<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
      
            sprintf<SPAN class="op">(</SPAN>m_signature<SPAN class="op">,</SPAN> 
                    <SPAN class="str">&quot;%s,%u,%d,%d:%dx%d,%d,%d,%d,%d,%d,%08X&quot;</SPAN><SPAN class="op">,</SPAN> 
                    m_typeface<SPAN class="op">,</SPAN>
                    m_char_set<SPAN class="op">,</SPAN>
                    <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>m_glyph_rendering<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                    m_resolution<SPAN class="op">,</SPAN>
                    m_height<SPAN class="op">,</SPAN>
                    m_width<SPAN class="op">,</SPAN>
                    m_weight<SPAN class="op">,</SPAN>
                    <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>m_italic<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                    <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>m_hinting<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                    <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>m_flip_y<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                    <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>m_pitch_and_family<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
                    gamma_hash<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_outline <SPAN class="op">||</SPAN>
               m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_mono <SPAN class="op">||</SPAN>
               m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_gray8<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">double</SPAN> mtx<SPAN class="op">[</SPAN><SPAN class="num">6</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">char</SPAN> buf<SPAN class="op">[</SPAN><SPAN class="num">100</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                m_affine<SPAN class="op">.</SPAN>store_to<SPAN class="op">(</SPAN>mtx<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                sprintf<SPAN class="op">(</SPAN>buf<SPAN class="op">,</SPAN> <SPAN class="str">&quot;,%08X%08X%08X%08X%08X%08X&quot;</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">0</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">1</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">2</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">3</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">4</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
                    dbl_to_plain_fx<SPAN class="op">(</SPAN>mtx<SPAN class="op">[</SPAN><SPAN class="num">5</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                strcat<SPAN class="op">(</SPAN>m_signature<SPAN class="op">,</SPAN> buf<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="op">++</SPAN>m_change_stamp<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">bool</SPAN> font_engine_win32_tt_base::prepare_glyph<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> glyph_code<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_dc <SPAN class="op">&amp;&amp;</SPAN> m_cur_font<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">int</SPAN> format <SPAN class="op">=</SPAN> GGO_BITMAP<SPAN class="op">;</SPAN>

            <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN>m_glyph_rendering<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
            <SPAN class="kw1">case</SPAN> glyph_ren_native_gray8: 
                format <SPAN class="op">=</SPAN> GGO_GRAY8_BITMAP<SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> glyph_ren_outline:
            <SPAN class="kw1">case</SPAN> glyph_ren_agg_mono:
            <SPAN class="kw1">case</SPAN> glyph_ren_agg_gray8:
                format <SPAN class="op">=</SPAN> GGO_NATIVE<SPAN class="op">;</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

<SPAN class="kw2">#ifndef</SPAN> GGO_UNHINTED         <SPAN class="rem">// For compatibility with old SDKs.</SPAN>
<SPAN class="kw2">#define</SPAN> GGO_UNHINTED <SPAN class="num">0x0100</SPAN>
<SPAN class="kw2">#endif</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>m_hinting<SPAN class="op">)</SPAN> format <SPAN class="op">|=</SPAN> GGO_UNHINTED<SPAN class="op">;</SPAN>
        
            GLYPHMETRICS gm<SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> total_size <SPAN class="op">=</SPAN> GetGlyphOutlineX<SPAN class="op">(</SPAN>m_dc<SPAN class="op">,</SPAN>
                                              glyph_code<SPAN class="op">,</SPAN>
                                              format<SPAN class="op">,</SPAN>
                                              <SPAN class="op">&amp;</SPAN>gm<SPAN class="op">,</SPAN>
                                              buf_size<SPAN class="op">,</SPAN>
                                              <SPAN class="op">(</SPAN><SPAN class="kw1">void</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN>m_gbuf<SPAN class="op">,</SPAN>
                                              <SPAN class="op">&amp;</SPAN>m_matrix<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>total_size <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> 
            <SPAN class="op">{</SPAN>
                <SPAN class="rem">// GetGlyphOutline() fails when being called for</SPAN>
                <SPAN class="rem">// GGO_GRAY8_BITMAP and white space (stupid Microsoft).</SPAN>
                <SPAN class="rem">// It doesn&#039;t even initialize the glyph metrics</SPAN>
                <SPAN class="rem">// structure. So, we have to query the metrics</SPAN>
                <SPAN class="rem">// separately (basically we need gmCellIncX).</SPAN>
                <SPAN class="kw1">int</SPAN> total_size <SPAN class="op">=</SPAN> GetGlyphOutlineX<SPAN class="op">(</SPAN>m_dc<SPAN class="op">,</SPAN>
                                                  glyph_code<SPAN class="op">,</SPAN>
                                                  GGO_METRICS<SPAN class="op">,</SPAN>
                                                  <SPAN class="op">&amp;</SPAN>gm<SPAN class="op">,</SPAN>
                                                  buf_size<SPAN class="op">,</SPAN>
                                                  <SPAN class="op">(</SPAN><SPAN class="kw1">void</SPAN><SPAN class="op">*</SPAN><SPAN class="op">)</SPAN>m_gbuf<SPAN class="op">,</SPAN>
                                                  <SPAN class="op">&amp;</SPAN>m_matrix<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>total_size <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
                gm<SPAN class="op">.</SPAN>gmBlackBoxX <SPAN class="op">=</SPAN> gm<SPAN class="op">.</SPAN>gmBlackBoxY <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
                total_size <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            m_glyph_index <SPAN class="op">=</SPAN> glyph_code<SPAN class="op">;</SPAN>
            m_advance_x <SPAN class="op">=</SPAN>  gm<SPAN class="op">.</SPAN>gmCellIncX<SPAN class="op">;</SPAN>
            m_advance_y <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>gm<SPAN class="op">.</SPAN>gmCellIncY<SPAN class="op">;</SPAN>

            <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN>m_glyph_rendering<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
            <SPAN class="kw1">case</SPAN> glyph_ren_native_mono: 
                decompose_win32_glyph_bitmap_mono<SPAN class="op">(</SPAN>m_gbuf<SPAN class="op">,</SPAN> 
                                                  gm<SPAN class="op">.</SPAN>gmBlackBoxX<SPAN class="op">,</SPAN>
                                                  gm<SPAN class="op">.</SPAN>gmBlackBoxY<SPAN class="op">,</SPAN>
                                                  gm<SPAN class="op">.</SPAN>gmptGlyphOrigin<SPAN class="op">.</SPAN>x<SPAN class="op">,</SPAN>
                                                  m_flip_y ? <SPAN class="op">-</SPAN>gm<SPAN class="op">.</SPAN>gmptGlyphOrigin<SPAN class="op">.</SPAN>y : 
                                                              gm<SPAN class="op">.</SPAN>gmptGlyphOrigin<SPAN class="op">.</SPAN>y<SPAN class="op">,</SPAN>
                                                  m_flip_y<SPAN class="op">,</SPAN>
                                                  m_scanline_bin<SPAN class="op">,</SPAN>
                                                  m_scanlines_bin<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                m_data_size <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> 
                m_data_type <SPAN class="op">=</SPAN> glyph_data_mono<SPAN class="op">;</SPAN>
                <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> glyph_ren_native_gray8:
                decompose_win32_glyph_bitmap_gray8<SPAN class="op">(</SPAN>m_gbuf<SPAN class="op">,</SPAN> 
                                                   gm<SPAN class="op">.</SPAN>gmBlackBoxX<SPAN class="op">,</SPAN>
                                                   gm<SPAN class="op">.</SPAN>gmBlackBoxY<SPAN class="op">,</SPAN>
                                                   gm<SPAN class="op">.</SPAN>gmptGlyphOrigin<SPAN class="op">.</SPAN>x<SPAN class="op">,</SPAN>
                                                   m_flip_y ? <SPAN class="op">-</SPAN>gm<SPAN class="op">.</SPAN>gmptGlyphOrigin<SPAN class="op">.</SPAN>y : 
                                                               gm<SPAN class="op">.</SPAN>gmptGlyphOrigin<SPAN class="op">.</SPAN>y<SPAN class="op">,</SPAN>
                                                   m_flip_y<SPAN class="op">,</SPAN>
                                                   m_rasterizer<SPAN class="op">,</SPAN>
                                                   m_scanline_aa<SPAN class="op">,</SPAN>
                                                   m_scanlines_aa<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                m_data_size <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> 
                m_data_type <SPAN class="op">=</SPAN> glyph_data_gray8<SPAN class="op">;</SPAN>
                <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> glyph_ren_outline:
                m_affine<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>m_advance_x<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>m_advance_y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_flag32<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    m_path32<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>decompose_win32_glyph_outline<SPAN class="op">(</SPAN>m_gbuf<SPAN class="op">,</SPAN>
                                                     total_size<SPAN class="op">,</SPAN>
                                                     m_flip_y<SPAN class="op">,</SPAN> 
                                                     m_affine<SPAN class="op">,</SPAN>
                                                     m_path32<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        <A href="../include/agg_basics.h.html#rect_d">rect_d</A> bnd  <SPAN class="op">=</SPAN> m_path32<SPAN class="op">.</SPAN><A href="../include/agg_bounding_rect.h.html#bounding_rect">bounding_rect</A><SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_data_size <SPAN class="op">=</SPAN> m_path32<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_data_type <SPAN class="op">=</SPAN> glyph_data_outline<SPAN class="op">;</SPAN>
                        m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>floor<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>x1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>floor<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>ceil<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>ceil<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    m_path16<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>decompose_win32_glyph_outline<SPAN class="op">(</SPAN>m_gbuf<SPAN class="op">,</SPAN>
                                                     total_size<SPAN class="op">,</SPAN>
                                                     m_flip_y<SPAN class="op">,</SPAN> 
                                                     m_affine<SPAN class="op">,</SPAN>
                                                     m_path16<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        <A href="../include/agg_basics.h.html#rect_d">rect_d</A> bnd  <SPAN class="op">=</SPAN> m_path16<SPAN class="op">.</SPAN><A href="../include/agg_bounding_rect.h.html#bounding_rect">bounding_rect</A><SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_data_size <SPAN class="op">=</SPAN> m_path16<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_data_type <SPAN class="op">=</SPAN> glyph_data_outline<SPAN class="op">;</SPAN>
                        m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>floor<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>x1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>floor<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>y1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>ceil<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>x2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>ceil<SPAN class="op">(</SPAN>bnd<SPAN class="op">.</SPAN>y2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> glyph_ren_agg_mono:
                m_rasterizer<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_affine<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>m_advance_x<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>m_advance_y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_flag32<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    m_path32<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    decompose_win32_glyph_outline<SPAN class="op">(</SPAN>m_gbuf<SPAN class="op">,</SPAN>
                                                  total_size<SPAN class="op">,</SPAN>
                                                  m_flip_y<SPAN class="op">,</SPAN> 
                                                  m_affine<SPAN class="op">,</SPAN>
                                                  m_path32<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_rasterizer<SPAN class="op">.</SPAN>add_path<SPAN class="op">(</SPAN>m_curves32<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    m_path16<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    decompose_win32_glyph_outline<SPAN class="op">(</SPAN>m_gbuf<SPAN class="op">,</SPAN>
                                                  total_size<SPAN class="op">,</SPAN>
                                                  m_flip_y<SPAN class="op">,</SPAN> 
                                                  m_affine<SPAN class="op">,</SPAN>
                                                  m_path16<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_rasterizer<SPAN class="op">.</SPAN>add_path<SPAN class="op">(</SPAN>m_curves16<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                m_scanlines_bin<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="rem">// Remove all </SPAN>
                <A href="../include/agg_renderer_scanline.h.html#render_scanlines">render_scanlines</A><SPAN class="op">(</SPAN>m_rasterizer<SPAN class="op">,</SPAN> m_scanline_bin<SPAN class="op">,</SPAN> m_scanlines_bin<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                m_data_size <SPAN class="op">=</SPAN> m_scanlines_bin<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> 
                m_data_type <SPAN class="op">=</SPAN> glyph_data_mono<SPAN class="op">;</SPAN>
                <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">case</SPAN> glyph_ren_agg_gray8:
                m_rasterizer<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_affine<SPAN class="op">.</SPAN>transform<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>m_advance_x<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>m_advance_y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_flag32<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    m_path32<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    decompose_win32_glyph_outline<SPAN class="op">(</SPAN>m_gbuf<SPAN class="op">,</SPAN>
                                                  total_size<SPAN class="op">,</SPAN>
                                                  m_flip_y<SPAN class="op">,</SPAN> 
                                                  m_affine<SPAN class="op">,</SPAN>
                                                  m_path32<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_rasterizer<SPAN class="op">.</SPAN>add_path<SPAN class="op">(</SPAN>m_curves32<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    m_path16<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    decompose_win32_glyph_outline<SPAN class="op">(</SPAN>m_gbuf<SPAN class="op">,</SPAN>
                                                  total_size<SPAN class="op">,</SPAN>
                                                  m_flip_y<SPAN class="op">,</SPAN> 
                                                  m_affine<SPAN class="op">,</SPAN>
                                                  m_path16<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    m_rasterizer<SPAN class="op">.</SPAN>add_path<SPAN class="op">(</SPAN>m_curves16<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                m_scanlines_aa<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="rem">// Remove all </SPAN>
                <A href="../include/agg_renderer_scanline.h.html#render_scanlines">render_scanlines</A><SPAN class="op">(</SPAN>m_rasterizer<SPAN class="op">,</SPAN> m_scanline_aa<SPAN class="op">,</SPAN> m_scanlines_aa<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>x1 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>min_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>y1 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>min_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>x2 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>max_x<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                m_bounds<SPAN class="op">.</SPAN>y2 <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>max_y<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                m_data_size <SPAN class="op">=</SPAN> m_scanlines_aa<SPAN class="op">.</SPAN>byte_size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> 
                m_data_type <SPAN class="op">=</SPAN> glyph_data_gray8<SPAN class="op">;</SPAN>
                <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">void</SPAN> font_engine_win32_tt_base::write_glyph_to<SPAN class="op">(</SPAN><A href="../include/agg_basics.h.html#int8u">int8u</A><SPAN class="op">*</SPAN> data<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>data <SPAN class="op">&amp;&amp;</SPAN> m_data_size<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">switch</SPAN><SPAN class="op">(</SPAN>m_data_type<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
            <SPAN class="kw1">case</SPAN> glyph_data_mono:    m_scanlines_bin<SPAN class="op">.</SPAN>serialize<SPAN class="op">(</SPAN>data<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">case</SPAN> glyph_data_gray8:   m_scanlines_aa<SPAN class="op">.</SPAN>serialize<SPAN class="op">(</SPAN>data<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>  <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">case</SPAN> glyph_data_outline:
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_flag32<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    m_path32<SPAN class="op">.</SPAN>serialize<SPAN class="op">(</SPAN>data<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    m_path16<SPAN class="op">.</SPAN>serialize<SPAN class="op">(</SPAN>data<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">bool</SPAN> pair_less<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> KERNINGPAIR<SPAN class="op">&amp;</SPAN> v1<SPAN class="op">,</SPAN> <SPAN class="kw1">const</SPAN> KERNINGPAIR<SPAN class="op">&amp;</SPAN> v2<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>v1<SPAN class="op">.</SPAN>wFirst <SPAN class="op">!=</SPAN> v2<SPAN class="op">.</SPAN>wFirst<SPAN class="op">)</SPAN> <SPAN class="kw1">return</SPAN> v1<SPAN class="op">.</SPAN>wFirst <SPAN class="op">&lt;</SPAN> v2<SPAN class="op">.</SPAN>wFirst<SPAN class="op">;</SPAN>
        <SPAN class="kw1">return</SPAN> v1<SPAN class="op">.</SPAN>wSecond <SPAN class="op">&lt;</SPAN> v2<SPAN class="op">.</SPAN>wSecond<SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">void</SPAN> font_engine_win32_tt_base::sort_kerning_pairs<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="../include/agg_array.h.html#pod_array_adaptor">pod_array_adaptor</A><SPAN class="op">&lt;</SPAN>KERNINGPAIR<SPAN class="op">&gt;</SPAN> pairs<SPAN class="op">(</SPAN>m_kerning_pairs<SPAN class="op">,</SPAN> m_num_kerning_pairs<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <A href="../include/agg_array.h.html#quick_sort">quick_sort</A><SPAN class="op">(</SPAN>pairs<SPAN class="op">,</SPAN> pair_less<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">void</SPAN> font_engine_win32_tt_base::load_kerning_pairs<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_dc <SPAN class="op">&amp;&amp;</SPAN> m_cur_font<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_kerning_pairs <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                m_kerning_pairs <SPAN class="op">=</SPAN> <SPAN class="kw1">new</SPAN> KERNINGPAIR <SPAN class="op">[</SPAN><SPAN class="num">16384</SPAN><SPAN class="op">-</SPAN><SPAN class="num">16</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN>
                m_max_kerning_pairs <SPAN class="op">=</SPAN> <SPAN class="num">16384</SPAN><SPAN class="op">-</SPAN><SPAN class="num">16</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            m_num_kerning_pairs <SPAN class="op">=</SPAN> ::GetKerningPairs<SPAN class="op">(</SPAN>m_dc<SPAN class="op">,</SPAN> 
                                                    m_max_kerning_pairs<SPAN class="op">,</SPAN>
                                                    m_kerning_pairs<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_num_kerning_pairs<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="rem">// Check to see if the kerning pairs are sorted and</SPAN>
                <SPAN class="rem">// sort them if they are not.</SPAN>
                <SPAN class="rem">//----------------</SPAN>
                <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">;</SPAN>
                <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> m_num_kerning_pairs<SPAN class="op">;</SPAN> <SPAN class="op">++</SPAN>i<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><SPAN class="op">!</SPAN>pair_less<SPAN class="op">(</SPAN>m_kerning_pairs<SPAN class="op">[</SPAN>i <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">]</SPAN><SPAN class="op">,</SPAN> m_kerning_pairs<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        sort_kerning_pairs<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                        <SPAN class="kw1">break</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="rem">//------------------------------------------------------------------------</SPAN>
    <SPAN class="kw1">bool</SPAN> font_engine_win32_tt_base::add_kerning<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> first<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> second<SPAN class="op">,</SPAN>
                                                <SPAN class="kw1">double</SPAN><SPAN class="op">*</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN><SPAN class="op">*</SPAN> y<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_dc <SPAN class="op">&amp;&amp;</SPAN> m_cur_font<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_num_kerning_pairs <SPAN class="op">==</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                load_kerning_pairs<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>

            <SPAN class="kw1">int</SPAN> end <SPAN class="op">=</SPAN> m_num_kerning_pairs <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> beg <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
            KERNINGPAIR t<SPAN class="op">;</SPAN>
            t<SPAN class="op">.</SPAN>wFirst <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>WORD<SPAN class="op">)</SPAN>first<SPAN class="op">;</SPAN>
            t<SPAN class="op">.</SPAN>wSecond <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>WORD<SPAN class="op">)</SPAN>second<SPAN class="op">;</SPAN>
            <SPAN class="kw1">while</SPAN><SPAN class="op">(</SPAN>beg <SPAN class="op">&lt;=</SPAN> end<SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">int</SPAN> mid <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>end <SPAN class="op">+</SPAN> beg<SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_kerning_pairs<SPAN class="op">[</SPAN>mid<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>wFirst  <SPAN class="op">==</SPAN> t<SPAN class="op">.</SPAN>wFirst <SPAN class="op">&amp;&amp;</SPAN>
                   m_kerning_pairs<SPAN class="op">[</SPAN>mid<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>wSecond <SPAN class="op">==</SPAN> t<SPAN class="op">.</SPAN>wSecond<SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    <SPAN class="kw1">double</SPAN> dx <SPAN class="op">=</SPAN> m_kerning_pairs<SPAN class="op">[</SPAN>mid<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>iKernAmount<SPAN class="op">;</SPAN>
                    <SPAN class="kw1">double</SPAN> dy <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_outline <SPAN class="op">||</SPAN>
                       m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_mono <SPAN class="op">||</SPAN>
                       m_glyph_rendering <SPAN class="op">==</SPAN> glyph_ren_agg_gray8<SPAN class="op">)</SPAN>
                    <SPAN class="op">{</SPAN>
                        m_affine<SPAN class="op">.</SPAN>transform_2x2<SPAN class="op">(</SPAN><SPAN class="op">&amp;</SPAN>dx<SPAN class="op">,</SPAN> <SPAN class="op">&amp;</SPAN>dy<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                    <SPAN class="op">}</SPAN>
                    <SPAN class="op">*</SPAN>x <SPAN class="op">+=</SPAN> dx<SPAN class="op">;</SPAN>
                    <SPAN class="op">*</SPAN>y <SPAN class="op">+=</SPAN> dy<SPAN class="op">;</SPAN>
                    <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>pair_less<SPAN class="op">(</SPAN>t<SPAN class="op">,</SPAN> m_kerning_pairs<SPAN class="op">[</SPAN>mid<SPAN class="op">]</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    end <SPAN class="op">=</SPAN> mid <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
                <SPAN class="kw1">else</SPAN>
                <SPAN class="op">{</SPAN>
                    beg <SPAN class="op">=</SPAN> mid <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
            <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>



<SPAN class="op">}</SPAN>

</PRE></TD></TR></TABLE><FONT style="margin-left:1em"><I></I></FONT><TABLE width="640px" bgcolor="#583927" height="1px" border="0" cellspacing="0" cellpadding="0" style="margin:0px;"><TR><TD></TD></TR></TABLE>
<TABLE width="640px" border="0" cellspacing="0" cellpadding="0">
<TR><TD><CENTER><SPAN class="authors">
Copyright <SPAN class="larger">&#169;</SPAN> 2002-2006
<A href="../../mcseem/index.html"><B>Maxim Shemanarev</B></A>
</SPAN></CENTER></TD></TR>
<TR><TD><CENTER><SPAN class="authors">
Web Design and Programming
<A href="../../mcseem/index.html"><B>Maxim Shemanarev</B></A>
</SPAN></CENTER></TD></TR>
</TABLE>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
</HTML>
