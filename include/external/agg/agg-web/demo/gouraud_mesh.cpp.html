<HTML><HEAD><TITLE>Anti-Grain Geometry - </TITLE>
<META http-equiv="Content-Type" content="text/html"/>
<LINK rel="stylesheet" type="text/css" href="../agg.styles.css"/>
</HEAD>
<TABLE width="640px" border="0" cellspacing="0" cellpadding="0"><TR><TD><PRE><SPAN class="kw2">#include</SPAN> <SPAN class="op">&lt;</SPAN>math<SPAN class="op">.</SPAN>h<SPAN class="op">&gt;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="op">&lt;</SPAN>stdio<SPAN class="op">.</SPAN>h<SPAN class="op">&gt;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="op">&lt;</SPAN>time<SPAN class="op">.</SPAN>h<SPAN class="op">&gt;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_rendering_buffer.h.html">agg_rendering_buffer.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_conv_transform.h.html">agg_conv_transform.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_conv_stroke.h.html">agg_conv_stroke.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_conv_clip_polyline.h.html">agg_conv_clip_polyline.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_scanline_u.h.html">agg_scanline_u.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_scanline_bin.h.html">agg_scanline_bin.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_renderer_scanline.h.html">agg_renderer_scanline.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_rasterizer_outline_aa.h.html">agg_rasterizer_outline_aa.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_rasterizer_scanline_aa.h.html">agg_rasterizer_scanline_aa.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_span_allocator.h.html">agg_span_allocator.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_span_gouraud_rgba.h.html">agg_span_gouraud_rgba.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_gamma_lut.h.html">agg_gamma_lut.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_arc.h.html">agg_arc.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_bezier_arc.h.html">agg_bezier_arc.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_pixfmt_rgb.h.html">agg_pixfmt_rgb.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_pixfmt_rgba.h.html">agg_pixfmt_rgba.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_bounding_rect.h.html">agg_bounding_rect.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_vpgen_clip_polygon.h.html">agg_vpgen_clip_polygon.h</A>&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;ctrl/agg_slider_ctrl.h&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;ctrl/agg_bezier_ctrl.h&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;ctrl/agg_rbox_ctrl.h&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;ctrl/agg_cbox_ctrl.h&quot;</SPAN>
<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;platform/agg_platform_support.h&quot;</SPAN>

<SPAN class="kw2">#include</SPAN> <SPAN class="str">&quot;<A href="../__code/include/agg_rasterizer_compound_aa.h.html">agg_rasterizer_compound_aa.h</A>&quot;</SPAN>


<SPAN class="kw1">enum</SPAN> <SPAN class="op">{</SPAN> flip_y <SPAN class="op">=</SPAN> <SPAN class="kw1">true</SPAN> <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>

<SPAN class="kw1">typedef</SPAN> agg::<A href="../__code/include/agg_pixfmt_rgba.h.html#pixfmt_bgra32_pre">pixfmt_bgra32_pre</A> <A href="../doc/basic_renderers/basic_renderers.agdoc.html#pixfmt">pixfmt</A><SPAN class="op">;</SPAN>


<SPAN class="kw1">namespace</SPAN> agg
<SPAN class="op">{</SPAN>

    <SPAN class="kw1">struct</SPAN> mesh_point
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">double</SPAN> x<SPAN class="op">,</SPAN>y<SPAN class="op">;</SPAN>
        <SPAN class="kw1">double</SPAN> dx<SPAN class="op">,</SPAN>dy<SPAN class="op">;</SPAN>
        <A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A> color<SPAN class="op">;</SPAN>
        <A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A> dc<SPAN class="op">;</SPAN>

        mesh_point<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN><SPAN class="op">}</SPAN>
        mesh_point<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> x_<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> y_<SPAN class="op">,</SPAN> 
                   <SPAN class="kw1">double</SPAN> dx_<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> dy_<SPAN class="op">,</SPAN> 
                   <A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A> c<SPAN class="op">,</SPAN> <A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A> dc_<SPAN class="op">)</SPAN> : 
            x<SPAN class="op">(</SPAN>x_<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> y<SPAN class="op">(</SPAN>y_<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
            dx<SPAN class="op">(</SPAN>dx_<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> dy<SPAN class="op">(</SPAN>dy_<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> 
            color<SPAN class="op">(</SPAN>c<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> dc<SPAN class="op">(</SPAN>dc_<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN><SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>

    <SPAN class="kw1">struct</SPAN> mesh_triangle
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">unsigned</SPAN> p1<SPAN class="op">,</SPAN> p2<SPAN class="op">,</SPAN> p3<SPAN class="op">;</SPAN>

        mesh_triangle<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN><SPAN class="op">}</SPAN>
        mesh_triangle<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> j<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> k<SPAN class="op">)</SPAN> : 
            p1<SPAN class="op">(</SPAN>i<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> p2<SPAN class="op">(</SPAN>j<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> p3<SPAN class="op">(</SPAN>k<SPAN class="op">)</SPAN> 
        <SPAN class="op">{</SPAN><SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>

    <SPAN class="kw1">struct</SPAN> mesh_edge
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">unsigned</SPAN> p1<SPAN class="op">,</SPAN> p2<SPAN class="op">;</SPAN>
        <SPAN class="kw1">int</SPAN>      tl<SPAN class="op">,</SPAN> tr<SPAN class="op">;</SPAN>

        mesh_edge<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN><SPAN class="op">}</SPAN>
        mesh_edge<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> p1_<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> p2_<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> tl_<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> tr_<SPAN class="op">)</SPAN> :
            p1<SPAN class="op">(</SPAN>p1_<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> p2<SPAN class="op">(</SPAN>p2_<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> tl<SPAN class="op">(</SPAN>tl_<SPAN class="op">)</SPAN><SPAN class="op">,</SPAN> tr<SPAN class="op">(</SPAN>tr_<SPAN class="op">)</SPAN> 
        <SPAN class="op">{</SPAN><SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>


    <SPAN class="kw1">static</SPAN> <SPAN class="kw1">double</SPAN> random<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> v1<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> v2<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="op">(</SPAN>v2 <SPAN class="op">-</SPAN> v1<SPAN class="op">)</SPAN> <SPAN class="op">*</SPAN> <SPAN class="op">(</SPAN>rand<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">%</SPAN> <SPAN class="num">1000</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> <SPAN class="num">999</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN> <SPAN class="op">+</SPAN> v1<SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="kw1">class</SPAN> mesh_ctrl
    <SPAN class="op">{</SPAN>
    <SPAN class="kw1">public</SPAN>:
        mesh_ctrl<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">void</SPAN> generate<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> cols<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> rows<SPAN class="op">,</SPAN> 
                      <SPAN class="kw1">double</SPAN> cell_w<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> cell_h<SPAN class="op">,</SPAN>
                      <SPAN class="kw1">double</SPAN> start_x<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> start_y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">void</SPAN> randomize_points<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> delta<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> 
        <SPAN class="kw1">void</SPAN> rotate_colors<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>


        <SPAN class="kw1">bool</SPAN> on_mouse_button_down<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> y<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> flags<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">bool</SPAN> on_mouse_move<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> y<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> flags<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">bool</SPAN> on_mouse_button_up<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> y<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> flags<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">unsigned</SPAN> num_vertices<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN> <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> m_vertices<SPAN class="op">.</SPAN>size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
        <SPAN class="kw1">const</SPAN> mesh_point<SPAN class="op">&amp;</SPAN> vertex<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN> <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> m_vertices<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
              mesh_point<SPAN class="op">&amp;</SPAN> vertex<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">)</SPAN>       <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> m_vertices<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>

        <SPAN class="kw1">const</SPAN> mesh_point<SPAN class="op">&amp;</SPAN> vertex<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> y<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN> <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> m_vertices<SPAN class="op">[</SPAN>y <SPAN class="op">*</SPAN> m_rows <SPAN class="op">+</SPAN> x<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
              mesh_point<SPAN class="op">&amp;</SPAN> vertex<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> y<SPAN class="op">)</SPAN>       <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> m_vertices<SPAN class="op">[</SPAN>y <SPAN class="op">*</SPAN> m_rows <SPAN class="op">+</SPAN> x<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>

        <SPAN class="kw1">unsigned</SPAN> num_triangles<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN> <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> m_triangles<SPAN class="op">.</SPAN>size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
        <SPAN class="kw1">const</SPAN> mesh_triangle<SPAN class="op">&amp;</SPAN> triangle<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN> <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> m_triangles<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
              mesh_triangle<SPAN class="op">&amp;</SPAN> triangle<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">)</SPAN>       <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> m_triangles<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>

        <SPAN class="kw1">unsigned</SPAN> num_edges<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN> <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> m_edges<SPAN class="op">.</SPAN>size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
        <SPAN class="kw1">const</SPAN> mesh_edge<SPAN class="op">&amp;</SPAN> edge<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN> <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> m_edges<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
              mesh_edge<SPAN class="op">&amp;</SPAN> edge<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">)</SPAN>       <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> m_edges<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>

    <SPAN class="kw1">private</SPAN>:
        <SPAN class="kw1">unsigned</SPAN> m_cols<SPAN class="op">;</SPAN>
        <SPAN class="kw1">unsigned</SPAN> m_rows<SPAN class="op">;</SPAN>
        <SPAN class="kw1">int</SPAN>      m_drag_idx<SPAN class="op">;</SPAN>
        <SPAN class="kw1">double</SPAN>   m_drag_dx<SPAN class="op">;</SPAN>
        <SPAN class="kw1">double</SPAN>   m_drag_dy<SPAN class="op">;</SPAN>
        <SPAN class="kw1">double</SPAN>   m_cell_w<SPAN class="op">;</SPAN>
        <SPAN class="kw1">double</SPAN>   m_cell_h<SPAN class="op">;</SPAN>
        <SPAN class="kw1">double</SPAN>   m_start_x<SPAN class="op">;</SPAN>
        <SPAN class="kw1">double</SPAN>   m_start_y<SPAN class="op">;</SPAN>
        <A href="../__code/include/agg_array.h.html#pod_bvector">pod_bvector</A><SPAN class="op">&lt;</SPAN>mesh_point<SPAN class="op">&gt;</SPAN>    m_vertices<SPAN class="op">;</SPAN>
        <A href="../__code/include/agg_array.h.html#pod_bvector">pod_bvector</A><SPAN class="op">&lt;</SPAN>mesh_triangle<SPAN class="op">&gt;</SPAN> m_triangles<SPAN class="op">;</SPAN>
        <A href="../__code/include/agg_array.h.html#pod_bvector">pod_bvector</A><SPAN class="op">&lt;</SPAN>mesh_edge<SPAN class="op">&gt;</SPAN>     m_edges<SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>


    mesh_ctrl::mesh_ctrl<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> :
        m_cols<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_rows<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_drag_idx<SPAN class="op">(</SPAN><SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_drag_dx<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
        m_drag_dy<SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN><SPAN class="op">}</SPAN>


    <SPAN class="kw1">void</SPAN> mesh_ctrl::generate<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> cols<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> rows<SPAN class="op">,</SPAN> 
                             <SPAN class="kw1">double</SPAN> cell_w<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> cell_h<SPAN class="op">,</SPAN>
                             <SPAN class="kw1">double</SPAN> start_x<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> start_y<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        m_cols <SPAN class="op">=</SPAN> cols<SPAN class="op">;</SPAN>
        m_rows <SPAN class="op">=</SPAN> rows<SPAN class="op">;</SPAN>
        m_cell_w <SPAN class="op">=</SPAN> cell_w<SPAN class="op">;</SPAN>
        m_cell_h <SPAN class="op">=</SPAN> cell_h<SPAN class="op">;</SPAN>
        m_start_x <SPAN class="op">=</SPAN> start_x<SPAN class="op">;</SPAN>
        m_start_y <SPAN class="op">=</SPAN> start_y<SPAN class="op">;</SPAN>

        m_vertices<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">,</SPAN> j<SPAN class="op">;</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> m_rows<SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">double</SPAN> x <SPAN class="op">=</SPAN> start_x<SPAN class="op">;</SPAN>
            <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>j <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> j <SPAN class="op">&lt;</SPAN> m_cols<SPAN class="op">;</SPAN> j<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">double</SPAN> dx <SPAN class="op">=</SPAN> random<SPAN class="op">(</SPAN><SPAN class="op">-</SPAN><SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">5</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">5</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">double</SPAN> dy <SPAN class="op">=</SPAN> random<SPAN class="op">(</SPAN><SPAN class="op">-</SPAN><SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">5</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">.</SPAN><SPAN class="num">5</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A> c<SPAN class="op">(</SPAN>rand<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&amp;</SPAN> <SPAN class="num">0xFF</SPAN><SPAN class="op">,</SPAN> rand<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&amp;</SPAN> <SPAN class="num">0xFF</SPAN><SPAN class="op">,</SPAN> rand<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&amp;</SPAN> <SPAN class="num">0xFF</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A> dc<SPAN class="op">(</SPAN>rand<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&amp;</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN> rand<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&amp;</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">,</SPAN> rand<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">&amp;</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_vertices<SPAN class="op">.</SPAN>add<SPAN class="op">(</SPAN>mesh_point<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> start_y<SPAN class="op">,</SPAN> dx<SPAN class="op">,</SPAN> dy<SPAN class="op">,</SPAN> c<SPAN class="op">,</SPAN> dc<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                x <SPAN class="op">+=</SPAN> cell_w<SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
            start_y <SPAN class="op">+=</SPAN> cell_h<SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>



        <SPAN class="rem">//  4---3</SPAN>
        <SPAN class="rem">//  |t2/|</SPAN>
        <SPAN class="rem">//  | / |</SPAN>
        <SPAN class="rem">//  |/t1|</SPAN>
        <SPAN class="rem">//  1---2</SPAN>
        m_triangles<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        m_edges<SPAN class="op">.</SPAN>remove_all<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> m_rows <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>j <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> j <SPAN class="op">&lt;</SPAN> m_cols <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> j<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">int</SPAN> p1 <SPAN class="op">=</SPAN> i <SPAN class="op">*</SPAN> m_cols <SPAN class="op">+</SPAN> j<SPAN class="op">;</SPAN>
                <SPAN class="kw1">int</SPAN> p2 <SPAN class="op">=</SPAN> p1 <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">int</SPAN> p3 <SPAN class="op">=</SPAN> p2 <SPAN class="op">+</SPAN> m_cols<SPAN class="op">;</SPAN>
                <SPAN class="kw1">int</SPAN> p4 <SPAN class="op">=</SPAN> p1 <SPAN class="op">+</SPAN> m_cols<SPAN class="op">;</SPAN>
                m_triangles<SPAN class="op">.</SPAN>add<SPAN class="op">(</SPAN>mesh_triangle<SPAN class="op">(</SPAN>p1<SPAN class="op">,</SPAN> p2<SPAN class="op">,</SPAN> p3<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_triangles<SPAN class="op">.</SPAN>add<SPAN class="op">(</SPAN>mesh_triangle<SPAN class="op">(</SPAN>p3<SPAN class="op">,</SPAN> p4<SPAN class="op">,</SPAN> p1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

                <SPAN class="kw1">int</SPAN> curr_cell <SPAN class="op">=</SPAN> i <SPAN class="op">*</SPAN> <SPAN class="op">(</SPAN>m_cols <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">+</SPAN> j<SPAN class="op">;</SPAN>
                <SPAN class="kw1">int</SPAN> left_cell <SPAN class="op">=</SPAN> j ? <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>curr_cell <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN> : <SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">int</SPAN> bott_cell <SPAN class="op">=</SPAN> i ? <SPAN class="kw1">int</SPAN><SPAN class="op">(</SPAN>curr_cell <SPAN class="op">-</SPAN> <SPAN class="op">(</SPAN>m_cols <SPAN class="op">-</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN> : <SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>

                <SPAN class="kw1">int</SPAN> curr_t1 <SPAN class="op">=</SPAN> curr_cell <SPAN class="op">*</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">int</SPAN> curr_t2 <SPAN class="op">=</SPAN> curr_t1 <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>

                <SPAN class="kw1">int</SPAN> left_t1 <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>left_cell <SPAN class="op">&gt;=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> ? left_cell <SPAN class="op">*</SPAN> <SPAN class="num">2</SPAN> : <SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">int</SPAN> left_t2 <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>left_cell <SPAN class="op">&gt;=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> ? left_t1 <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN>   : <SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>

                <SPAN class="kw1">int</SPAN> bott_t1 <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>bott_cell <SPAN class="op">&gt;=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> ? bott_cell <SPAN class="op">*</SPAN> <SPAN class="num">2</SPAN> : <SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">int</SPAN> bott_t2 <SPAN class="op">=</SPAN> <SPAN class="op">(</SPAN>bott_cell <SPAN class="op">&gt;=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> ? bott_t1 <SPAN class="op">+</SPAN> <SPAN class="num">1</SPAN>   : <SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
                
                m_edges<SPAN class="op">.</SPAN>add<SPAN class="op">(</SPAN>mesh_edge<SPAN class="op">(</SPAN>p1<SPAN class="op">,</SPAN> p2<SPAN class="op">,</SPAN> curr_t1<SPAN class="op">,</SPAN> bott_t2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_edges<SPAN class="op">.</SPAN>add<SPAN class="op">(</SPAN>mesh_edge<SPAN class="op">(</SPAN>p1<SPAN class="op">,</SPAN> p3<SPAN class="op">,</SPAN> curr_t2<SPAN class="op">,</SPAN> curr_t1<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_edges<SPAN class="op">.</SPAN>add<SPAN class="op">(</SPAN>mesh_edge<SPAN class="op">(</SPAN>p1<SPAN class="op">,</SPAN> p4<SPAN class="op">,</SPAN> left_t1<SPAN class="op">,</SPAN> curr_t2<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>j <SPAN class="op">==</SPAN> m_cols <SPAN class="op">-</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">)</SPAN> <SPAN class="rem">// Last column</SPAN>
                <SPAN class="op">{</SPAN>
                    m_edges<SPAN class="op">.</SPAN>add<SPAN class="op">(</SPAN>mesh_edge<SPAN class="op">(</SPAN>p2<SPAN class="op">,</SPAN> p3<SPAN class="op">,</SPAN> curr_t1<SPAN class="op">,</SPAN> <SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>

                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">==</SPAN> m_rows <SPAN class="op">-</SPAN> <SPAN class="num">2</SPAN><SPAN class="op">)</SPAN> <SPAN class="rem">// Last row</SPAN>
                <SPAN class="op">{</SPAN>
                    m_edges<SPAN class="op">.</SPAN>add<SPAN class="op">(</SPAN>mesh_edge<SPAN class="op">(</SPAN>p3<SPAN class="op">,</SPAN> p4<SPAN class="op">,</SPAN> curr_t2<SPAN class="op">,</SPAN> <SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="kw1">void</SPAN> mesh_ctrl::randomize_points<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> delta<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">,</SPAN> j<SPAN class="op">;</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> m_rows<SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>j <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> j <SPAN class="op">&lt;</SPAN> m_cols<SPAN class="op">;</SPAN> j<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">double</SPAN> xc <SPAN class="op">=</SPAN> j <SPAN class="op">*</SPAN> m_cell_w <SPAN class="op">+</SPAN> m_start_x<SPAN class="op">;</SPAN>
                <SPAN class="kw1">double</SPAN> yc <SPAN class="op">=</SPAN> i <SPAN class="op">*</SPAN> m_cell_h <SPAN class="op">+</SPAN> m_start_y<SPAN class="op">;</SPAN>
                <SPAN class="kw1">double</SPAN> x1 <SPAN class="op">=</SPAN> xc <SPAN class="op">-</SPAN> m_cell_w <SPAN class="op">/</SPAN> <SPAN class="num">4</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">double</SPAN> y1 <SPAN class="op">=</SPAN> yc <SPAN class="op">-</SPAN> m_cell_h <SPAN class="op">/</SPAN> <SPAN class="num">4</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">double</SPAN> x2 <SPAN class="op">=</SPAN> xc <SPAN class="op">+</SPAN> m_cell_w <SPAN class="op">/</SPAN> <SPAN class="num">4</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">double</SPAN> y2 <SPAN class="op">=</SPAN> yc <SPAN class="op">+</SPAN> m_cell_h <SPAN class="op">/</SPAN> <SPAN class="num">4</SPAN><SPAN class="op">;</SPAN>
                mesh_point<SPAN class="op">&amp;</SPAN> p <SPAN class="op">=</SPAN> vertex<SPAN class="op">(</SPAN>j<SPAN class="op">,</SPAN> i<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                p<SPAN class="op">.</SPAN>x <SPAN class="op">+=</SPAN> p<SPAN class="op">.</SPAN>dx<SPAN class="op">;</SPAN>
                p<SPAN class="op">.</SPAN>y <SPAN class="op">+=</SPAN> p<SPAN class="op">.</SPAN>dy<SPAN class="op">;</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>p<SPAN class="op">.</SPAN>x <SPAN class="op">&lt;</SPAN> x1<SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> p<SPAN class="op">.</SPAN>x <SPAN class="op">=</SPAN> x1<SPAN class="op">;</SPAN> p<SPAN class="op">.</SPAN>dx <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>p<SPAN class="op">.</SPAN>dx<SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>p<SPAN class="op">.</SPAN>y <SPAN class="op">&lt;</SPAN> y1<SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> p<SPAN class="op">.</SPAN>y <SPAN class="op">=</SPAN> y1<SPAN class="op">;</SPAN> p<SPAN class="op">.</SPAN>dy <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>p<SPAN class="op">.</SPAN>dy<SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>p<SPAN class="op">.</SPAN>x <SPAN class="op">&gt;</SPAN> x2<SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> p<SPAN class="op">.</SPAN>x <SPAN class="op">=</SPAN> x2<SPAN class="op">;</SPAN> p<SPAN class="op">.</SPAN>dx <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>p<SPAN class="op">.</SPAN>dx<SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>p<SPAN class="op">.</SPAN>y <SPAN class="op">&gt;</SPAN> y2<SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> p<SPAN class="op">.</SPAN>y <SPAN class="op">=</SPAN> y2<SPAN class="op">;</SPAN> p<SPAN class="op">.</SPAN>dy <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN>p<SPAN class="op">.</SPAN>dy<SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="kw1">void</SPAN> mesh_ctrl::rotate_colors<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">;</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> m_vertices<SPAN class="op">.</SPAN>size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A><SPAN class="op">&amp;</SPAN> c <SPAN class="op">=</SPAN> m_vertices<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>color<SPAN class="op">;</SPAN>
            <A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A><SPAN class="op">&amp;</SPAN> dc <SPAN class="op">=</SPAN> m_vertices<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>dc<SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> r <SPAN class="op">=</SPAN> c<SPAN class="op">.</SPAN>r <SPAN class="op">+</SPAN> <SPAN class="op">(</SPAN>dc<SPAN class="op">.</SPAN>r ? <SPAN class="num">5</SPAN> : <SPAN class="op">-</SPAN><SPAN class="num">5</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> g <SPAN class="op">=</SPAN> c<SPAN class="op">.</SPAN>g <SPAN class="op">+</SPAN> <SPAN class="op">(</SPAN>dc<SPAN class="op">.</SPAN>g ? <SPAN class="num">5</SPAN> : <SPAN class="op">-</SPAN><SPAN class="num">5</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">int</SPAN> b <SPAN class="op">=</SPAN> c<SPAN class="op">.</SPAN>b <SPAN class="op">+</SPAN> <SPAN class="op">(</SPAN>dc<SPAN class="op">.</SPAN>b ? <SPAN class="num">5</SPAN> : <SPAN class="op">-</SPAN><SPAN class="num">5</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>r <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> r <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> dc<SPAN class="op">.</SPAN>r <SPAN class="op">^=</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN> <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>r <SPAN class="op">&gt;</SPAN> <SPAN class="num">255</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> r <SPAN class="op">=</SPAN> <SPAN class="num">255</SPAN><SPAN class="op">;</SPAN> dc<SPAN class="op">.</SPAN>r <SPAN class="op">^=</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>g <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> g <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> dc<SPAN class="op">.</SPAN>g <SPAN class="op">^=</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN> <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>g <SPAN class="op">&gt;</SPAN> <SPAN class="num">255</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> g <SPAN class="op">=</SPAN> <SPAN class="num">255</SPAN><SPAN class="op">;</SPAN> dc<SPAN class="op">.</SPAN>g <SPAN class="op">^=</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>b <SPAN class="op">&lt;</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> b <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> dc<SPAN class="op">.</SPAN>b <SPAN class="op">^=</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN> <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>b <SPAN class="op">&gt;</SPAN> <SPAN class="num">255</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">{</SPAN> b <SPAN class="op">=</SPAN> <SPAN class="num">255</SPAN><SPAN class="op">;</SPAN> dc<SPAN class="op">.</SPAN>b <SPAN class="op">^=</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>
            c<SPAN class="op">.</SPAN>r <SPAN class="op">=</SPAN> r<SPAN class="op">;</SPAN>
            c<SPAN class="op">.</SPAN>g <SPAN class="op">=</SPAN> g<SPAN class="op">;</SPAN>
            c<SPAN class="op">.</SPAN>b <SPAN class="op">=</SPAN> b<SPAN class="op">;</SPAN> 
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="kw1">bool</SPAN> mesh_ctrl::on_mouse_button_down<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> y<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> flags<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flags <SPAN class="op">&amp;</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">;</SPAN>
            <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> m_vertices<SPAN class="op">.</SPAN>size<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN><A href="../__code/include/agg_math.h.html#calc_distance">calc_distance</A><SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> y<SPAN class="op">,</SPAN> m_vertices<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>x<SPAN class="op">,</SPAN> m_vertices<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN> <SPAN class="op">&lt;</SPAN> <SPAN class="num">5</SPAN><SPAN class="op">)</SPAN>
                <SPAN class="op">{</SPAN>
                    m_drag_idx <SPAN class="op">=</SPAN> i<SPAN class="op">;</SPAN>
                    m_drag_dx <SPAN class="op">=</SPAN> x <SPAN class="op">-</SPAN> m_vertices<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>x<SPAN class="op">;</SPAN>
                    m_drag_dy <SPAN class="op">=</SPAN> y <SPAN class="op">-</SPAN> m_vertices<SPAN class="op">[</SPAN>i<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>y<SPAN class="op">;</SPAN>
                    <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="op">}</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="kw1">bool</SPAN> mesh_ctrl::on_mouse_move<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> y<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> flags<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>flags <SPAN class="op">&amp;</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_drag_idx <SPAN class="op">&gt;=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                m_vertices<SPAN class="op">[</SPAN>m_drag_idx<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>x <SPAN class="op">=</SPAN> x <SPAN class="op">-</SPAN> m_drag_dx<SPAN class="op">;</SPAN>
                m_vertices<SPAN class="op">[</SPAN>m_drag_idx<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>y <SPAN class="op">=</SPAN> y <SPAN class="op">-</SPAN> m_drag_dy<SPAN class="op">;</SPAN>
                <SPAN class="kw1">return</SPAN> <SPAN class="kw1">true</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">else</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">return</SPAN> on_mouse_button_up<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> y<SPAN class="op">,</SPAN> flags<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="kw1">bool</SPAN> mesh_ctrl::on_mouse_button_up<SPAN class="op">(</SPAN><SPAN class="kw1">double</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">double</SPAN> y<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> flags<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">bool</SPAN> ret <SPAN class="op">=</SPAN> m_drag_idx <SPAN class="op">&gt;=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN>
        m_drag_idx <SPAN class="op">=</SPAN> <SPAN class="op">-</SPAN><SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">return</SPAN> ret<SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>



    <SPAN class="kw1">class</SPAN> styles_gouraud
    <SPAN class="op">{</SPAN>
    <SPAN class="kw1">public</SPAN>:
        <SPAN class="kw1">typedef</SPAN> <A href="../__code/include/agg_span_gouraud_rgba.h.html#span_gouraud_rgba">span_gouraud_rgba</A><SPAN class="op">&lt;</SPAN><A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A><SPAN class="op">&gt;</SPAN> gouraud_type<SPAN class="op">;</SPAN>

        <SPAN class="kw1">template</SPAN><SPAN class="op">&lt;</SPAN><SPAN class="kw1">class</SPAN> Gamma<SPAN class="op">&gt;</SPAN>
        styles_gouraud<SPAN class="op">(</SPAN><SPAN class="kw1">const</SPAN> mesh_ctrl<SPAN class="op">&amp;</SPAN> mesh<SPAN class="op">,</SPAN> <SPAN class="kw1">const</SPAN> Gamma<SPAN class="op">&amp;</SPAN> gamma<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">;</SPAN>
            <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> mesh<SPAN class="op">.</SPAN>num_triangles<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
            <SPAN class="op">{</SPAN>
                <SPAN class="kw1">const</SPAN> agg::mesh_triangle<SPAN class="op">&amp;</SPAN> t <SPAN class="op">=</SPAN> mesh<SPAN class="op">.</SPAN>triangle<SPAN class="op">(</SPAN>i<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">const</SPAN> agg::mesh_point<SPAN class="op">&amp;</SPAN> p1 <SPAN class="op">=</SPAN> mesh<SPAN class="op">.</SPAN>vertex<SPAN class="op">(</SPAN>t<SPAN class="op">.</SPAN>p1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">const</SPAN> agg::mesh_point<SPAN class="op">&amp;</SPAN> p2 <SPAN class="op">=</SPAN> mesh<SPAN class="op">.</SPAN>vertex<SPAN class="op">(</SPAN>t<SPAN class="op">.</SPAN>p2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                <SPAN class="kw1">const</SPAN> agg::mesh_point<SPAN class="op">&amp;</SPAN> p3 <SPAN class="op">=</SPAN> mesh<SPAN class="op">.</SPAN>vertex<SPAN class="op">(</SPAN>t<SPAN class="op">.</SPAN>p3<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

                agg::<A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A> c1 <SPAN class="op">=</SPAN> p1<SPAN class="op">.</SPAN>color<SPAN class="op">;</SPAN> 
                agg::<A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A> c2 <SPAN class="op">=</SPAN> p2<SPAN class="op">.</SPAN>color<SPAN class="op">;</SPAN> 
                agg::<A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A> c3 <SPAN class="op">=</SPAN> p3<SPAN class="op">.</SPAN>color<SPAN class="op">;</SPAN>
                c1<SPAN class="op">.</SPAN>apply_gamma_dir<SPAN class="op">(</SPAN>gamma<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                c2<SPAN class="op">.</SPAN>apply_gamma_dir<SPAN class="op">(</SPAN>gamma<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                c3<SPAN class="op">.</SPAN>apply_gamma_dir<SPAN class="op">(</SPAN>gamma<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                gouraud_type gouraud<SPAN class="op">(</SPAN>c1<SPAN class="op">,</SPAN> c2<SPAN class="op">,</SPAN> c3<SPAN class="op">,</SPAN>
                                     p1<SPAN class="op">.</SPAN>x<SPAN class="op">,</SPAN> p1<SPAN class="op">.</SPAN>y<SPAN class="op">,</SPAN> 
                                     p2<SPAN class="op">.</SPAN>x<SPAN class="op">,</SPAN> p2<SPAN class="op">.</SPAN>y<SPAN class="op">,</SPAN>
                                     p3<SPAN class="op">.</SPAN>x<SPAN class="op">,</SPAN> p3<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                gouraud<SPAN class="op">.</SPAN>prepare<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
                m_triangles<SPAN class="op">.</SPAN>add<SPAN class="op">(</SPAN>gouraud<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="op">}</SPAN>
        <SPAN class="op">}</SPAN>

        <SPAN class="kw1">bool</SPAN> is_solid<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> style<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN> <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> <SPAN class="kw1">false</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>

        <A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A> color<SPAN class="op">(</SPAN><SPAN class="kw1">unsigned</SPAN> style<SPAN class="op">)</SPAN> <SPAN class="kw1">const</SPAN> <SPAN class="op">{</SPAN> <SPAN class="kw1">return</SPAN> <A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A><SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">,</SPAN><SPAN class="num">0</SPAN><SPAN class="op">,</SPAN><SPAN class="num">0</SPAN><SPAN class="op">,</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> <SPAN class="op">}</SPAN>

        <SPAN class="kw1">void</SPAN> generate_span<SPAN class="op">(</SPAN><A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A><SPAN class="op">*</SPAN> span<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> y<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> len<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> style<SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            m_triangles<SPAN class="op">[</SPAN>style<SPAN class="op">]</SPAN><SPAN class="op">.</SPAN>generate<SPAN class="op">(</SPAN>span<SPAN class="op">,</SPAN> x<SPAN class="op">,</SPAN> y<SPAN class="op">,</SPAN> len<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>

    <SPAN class="kw1">private</SPAN>:
        <A href="../__code/include/agg_array.h.html#pod_bvector">pod_bvector</A><SPAN class="op">&lt;</SPAN>gouraud_type<SPAN class="op">&gt;</SPAN> m_triangles<SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>
<SPAN class="op">}</SPAN>





<SPAN class="kw1">class</SPAN> the_application : <SPAN class="kw1">public</SPAN> agg::platform_support
<SPAN class="op">{</SPAN>

<SPAN class="kw1">public</SPAN>:
    <SPAN class="kw1">typedef</SPAN> agg::<A href="../doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</A><SPAN class="op">&lt;</SPAN><A href="../doc/basic_renderers/basic_renderers.agdoc.html#pixfmt">pixfmt</A><SPAN class="op">&gt;</SPAN> <A href="../doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</A><SPAN class="op">;</SPAN>
    <SPAN class="kw1">typedef</SPAN> agg::<A href="../__code/include/agg_renderer_scanline.h.html#renderer_scanline_aa_solid">renderer_scanline_aa_solid</A><SPAN class="op">&lt;</SPAN><A href="../doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</A><SPAN class="op">&gt;</SPAN> renderer_scanline<SPAN class="op">;</SPAN>
    <SPAN class="kw1">typedef</SPAN> agg::<A href="../__code/include/agg_rasterizer_scanline_aa.h.html#rasterizer_scanline_aa">rasterizer_scanline_aa</A><SPAN class="op">&lt;</SPAN><SPAN class="op">&gt;</SPAN> rasterizer_scanline<SPAN class="op">;</SPAN>
    <SPAN class="kw1">typedef</SPAN> agg::<A href="../__code/include/agg_scanline_u.h.html#scanline_u8">scanline_u8</A> scanline<SPAN class="op">;</SPAN>

    agg::mesh_ctrl      m_mesh<SPAN class="op">;</SPAN>
    agg::gamma_lut<SPAN class="op">&lt;</SPAN><SPAN class="op">&gt;</SPAN>    m_gamma<SPAN class="op">;</SPAN>


    the_application<SPAN class="op">(</SPAN>agg::pix_format_e format<SPAN class="op">,</SPAN> <SPAN class="kw1">bool</SPAN> flip_y<SPAN class="op">)</SPAN> :
        agg::platform_support<SPAN class="op">(</SPAN>format<SPAN class="op">,</SPAN> flip_y<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
<SPAN class="rem">//        m_gamma.gamma(2.0);</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="kw1">virtual</SPAN> <SPAN class="kw1">void</SPAN> on_init<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        m_mesh<SPAN class="op">.</SPAN>generate<SPAN class="op">(</SPAN><SPAN class="num">20</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">20</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">17</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">17</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">40</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">40</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>


    <SPAN class="kw1">virtual</SPAN> <SPAN class="kw1">void</SPAN> on_draw<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
        <A href="../doc/basic_renderers/basic_renderers.agdoc.html#pixfmt">pixfmt</A> pf<SPAN class="op">(</SPAN>rbuf_window<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <A href="../doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</A> ren_base<SPAN class="op">(</SPAN>pf<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        ren_base<SPAN class="op">.</SPAN>clear<SPAN class="op">(</SPAN>agg::<A href="../__code/include/agg_color_rgba.h.html#rgba">rgba</A><SPAN class="op">(</SPAN><SPAN class="num">0</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        renderer_scanline ren<SPAN class="op">(</SPAN>ren_base<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        rasterizer_scanline ras<SPAN class="op">;</SPAN>
        agg::<A href="../__code/include/agg_scanline_u.h.html#scanline_u8">scanline_u8</A> sl<SPAN class="op">;</SPAN>
        agg::<A href="../__code/include/agg_scanline_bin.h.html#scanline_bin">scanline_bin</A> sl_bin<SPAN class="op">;</SPAN>

        agg::<A href="../__code/include/agg_rasterizer_compound_aa.h.html#rasterizer_compound_aa">rasterizer_compound_aa</A><SPAN class="op">&lt;</SPAN><SPAN class="op">&gt;</SPAN> rasc<SPAN class="op">;</SPAN>
        agg::<A href="../__code/include/agg_span_allocator.h.html#span_allocator">span_allocator</A><SPAN class="op">&lt;</SPAN>agg::<A href="../__code/include/agg_color_rgba.h.html#rgba8">rgba8</A><SPAN class="op">&gt;</SPAN> alloc<SPAN class="op">;</SPAN>

        <SPAN class="kw1">unsigned</SPAN> i<SPAN class="op">;</SPAN>
        agg::styles_gouraud styles<SPAN class="op">(</SPAN>m_mesh<SPAN class="op">,</SPAN> m_gamma<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        start_timer<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        rasc<SPAN class="op">.</SPAN>reset<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="rem">//rasc.clip_box(40, 40, width() - 40, height() - 40);</SPAN>
        <SPAN class="kw1">for</SPAN><SPAN class="op">(</SPAN>i <SPAN class="op">=</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">;</SPAN> i <SPAN class="op">&lt;</SPAN> m_mesh<SPAN class="op">.</SPAN>num_edges<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN> i<SPAN class="op">++</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            <SPAN class="kw1">const</SPAN> agg::mesh_edge<SPAN class="op">&amp;</SPAN> e <SPAN class="op">=</SPAN> m_mesh<SPAN class="op">.</SPAN>edge<SPAN class="op">(</SPAN>i<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> agg::mesh_point<SPAN class="op">&amp;</SPAN> p1 <SPAN class="op">=</SPAN> m_mesh<SPAN class="op">.</SPAN>vertex<SPAN class="op">(</SPAN>e<SPAN class="op">.</SPAN>p1<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            <SPAN class="kw1">const</SPAN> agg::mesh_point<SPAN class="op">&amp;</SPAN> p2 <SPAN class="op">=</SPAN> m_mesh<SPAN class="op">.</SPAN>vertex<SPAN class="op">(</SPAN>e<SPAN class="op">.</SPAN>p2<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            rasc<SPAN class="op">.</SPAN>styles<SPAN class="op">(</SPAN>e<SPAN class="op">.</SPAN>tl<SPAN class="op">,</SPAN> e<SPAN class="op">.</SPAN>tr<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            rasc<SPAN class="op">.</SPAN>move_to_d<SPAN class="op">(</SPAN>p1<SPAN class="op">.</SPAN>x<SPAN class="op">,</SPAN> p1<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
            rasc<SPAN class="op">.</SPAN>line_to_d<SPAN class="op">(</SPAN>p2<SPAN class="op">.</SPAN>x<SPAN class="op">,</SPAN> p2<SPAN class="op">.</SPAN>y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
        agg::<A href="../__code/include/agg_renderer_scanline.h.html#render_scanlines_compound">render_scanlines_compound</A><SPAN class="op">(</SPAN>rasc<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> sl_bin<SPAN class="op">,</SPAN> ren_base<SPAN class="op">,</SPAN> alloc<SPAN class="op">,</SPAN> styles<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">double</SPAN> tm <SPAN class="op">=</SPAN> elapsed_time<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        <SPAN class="kw1">char</SPAN> buf<SPAN class="op">[</SPAN><SPAN class="num">256</SPAN><SPAN class="op">]</SPAN><SPAN class="op">;</SPAN> 
        agg::<A href="../__code/include/agg_gsv_text.h.html#gsv_text">gsv_text</A> t<SPAN class="op">;</SPAN>
        t<SPAN class="op">.</SPAN>size<SPAN class="op">(</SPAN><SPAN class="num">10</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        agg::<A href="../__code/include/agg_conv_stroke.h.html#conv_stroke">conv_stroke</A><SPAN class="op">&lt;</SPAN>agg::<A href="../__code/include/agg_gsv_text.h.html#gsv_text">gsv_text</A><SPAN class="op">&gt;</SPAN> pt<SPAN class="op">(</SPAN>t<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        pt<SPAN class="op">.</SPAN>width<SPAN class="op">(</SPAN><SPAN class="num">1</SPAN><SPAN class="op">.</SPAN><SPAN class="num">5</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        pt<SPAN class="op">.</SPAN>line_cap<SPAN class="op">(</SPAN>agg::round_cap<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        pt<SPAN class="op">.</SPAN>line_join<SPAN class="op">(</SPAN>agg::round_join<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        sprintf<SPAN class="op">(</SPAN>buf<SPAN class="op">,</SPAN> <SPAN class="str">&quot;%3.2f ms, %d triangles, %.0f tri/sec&quot;</SPAN><SPAN class="op">,</SPAN> 
            tm<SPAN class="op">,</SPAN> 
            m_mesh<SPAN class="op">.</SPAN>num_triangles<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">,</SPAN>
            m_mesh<SPAN class="op">.</SPAN>num_triangles<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">/</SPAN> tm <SPAN class="op">*</SPAN> <SPAN class="num">1000</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        t<SPAN class="op">.</SPAN>start_point<SPAN class="op">(</SPAN><SPAN class="num">10</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">10</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        t<SPAN class="op">.</SPAN>text<SPAN class="op">(</SPAN>buf<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

        ras<SPAN class="op">.</SPAN>add_path<SPAN class="op">(</SPAN>pt<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        agg::<A href="../__code/include/agg_renderer_scanline.h.html#render_scanlines_aa_solid">render_scanlines_aa_solid</A><SPAN class="op">(</SPAN>ras<SPAN class="op">,</SPAN> sl<SPAN class="op">,</SPAN> ren_base<SPAN class="op">,</SPAN> agg::<A href="../__code/include/agg_color_rgba.h.html#rgba">rgba</A><SPAN class="op">(</SPAN><SPAN class="num">1</SPAN><SPAN class="op">,</SPAN><SPAN class="num">1</SPAN><SPAN class="op">,</SPAN><SPAN class="num">1</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>


        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_gamma<SPAN class="op">.</SPAN>gamma<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> <SPAN class="op">!=</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            pf<SPAN class="op">.</SPAN>apply_gamma_inv<SPAN class="op">(</SPAN>m_gamma<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="kw1">virtual</SPAN> <SPAN class="kw1">void</SPAN> on_mouse_move<SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> y<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> flags<SPAN class="op">)</SPAN> 
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_mesh<SPAN class="op">.</SPAN>on_mouse_move<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> y<SPAN class="op">,</SPAN> flags<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            force_redraw<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="kw1">virtual</SPAN> <SPAN class="kw1">void</SPAN> on_mouse_button_down<SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> y<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> flags<SPAN class="op">)</SPAN> 
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_mesh<SPAN class="op">.</SPAN>on_mouse_button_down<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> y<SPAN class="op">,</SPAN> flags<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            force_redraw<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="kw1">virtual</SPAN> <SPAN class="kw1">void</SPAN> on_mouse_button_up<SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> y<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> flags<SPAN class="op">)</SPAN> 
    <SPAN class="op">{</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>m_mesh<SPAN class="op">.</SPAN>on_mouse_button_up<SPAN class="op">(</SPAN>x<SPAN class="op">,</SPAN> y<SPAN class="op">,</SPAN> flags<SPAN class="op">)</SPAN><SPAN class="op">)</SPAN>
        <SPAN class="op">{</SPAN>
            force_redraw<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="op">}</SPAN>
    <SPAN class="op">}</SPAN>
    
    <SPAN class="kw1">virtual</SPAN> <SPAN class="kw1">void</SPAN> on_key<SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN> x<SPAN class="op">,</SPAN> <SPAN class="kw1">int</SPAN> y<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> key<SPAN class="op">,</SPAN> <SPAN class="kw1">unsigned</SPAN> flags<SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="kw1">void</SPAN> on_idle<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN> 
    <SPAN class="op">{</SPAN>
        m_mesh<SPAN class="op">.</SPAN>randomize_points<SPAN class="op">(</SPAN><SPAN class="num">1</SPAN><SPAN class="op">.</SPAN><SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        m_mesh<SPAN class="op">.</SPAN>rotate_colors<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        force_redraw<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>

    <SPAN class="kw1">virtual</SPAN> <SPAN class="kw1">void</SPAN> on_ctrl_change<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN>
    <SPAN class="op">{</SPAN>
    <SPAN class="op">}</SPAN>
<SPAN class="op">}</SPAN><SPAN class="op">;</SPAN>


<SPAN class="kw1">int</SPAN> agg_main<SPAN class="op">(</SPAN><SPAN class="kw1">int</SPAN> argc<SPAN class="op">,</SPAN> <SPAN class="kw1">char</SPAN><SPAN class="op">*</SPAN> argv<SPAN class="op">[</SPAN><SPAN class="op">]</SPAN><SPAN class="op">)</SPAN>
<SPAN class="op">{</SPAN>
    the_application app<SPAN class="op">(</SPAN>agg::pix_format_bgra32<SPAN class="op">,</SPAN> flip_y<SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    app<SPAN class="op">.</SPAN>caption<SPAN class="op">(</SPAN><SPAN class="str">&quot;AGG Example&quot;</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>

    <SPAN class="kw1">if</SPAN><SPAN class="op">(</SPAN>app<SPAN class="op">.</SPAN>init<SPAN class="op">(</SPAN><SPAN class="num">400</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">400</SPAN><SPAN class="op">,</SPAN> <SPAN class="num">0</SPAN><SPAN class="op">)</SPAN><SPAN class="op">)</SPAN><SPAN class="rem">//agg::window_resize))</SPAN>
    <SPAN class="op">{</SPAN>
        app<SPAN class="op">.</SPAN>wait_mode<SPAN class="op">(</SPAN><SPAN class="kw1">false</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
        <SPAN class="kw1">return</SPAN> app<SPAN class="op">.</SPAN>run<SPAN class="op">(</SPAN><SPAN class="op">)</SPAN><SPAN class="op">;</SPAN>
    <SPAN class="op">}</SPAN>
    <SPAN class="kw1">return</SPAN> <SPAN class="num">1</SPAN><SPAN class="op">;</SPAN>
<SPAN class="op">}</SPAN>





</PRE></TD></TR></TABLE><FONT style="margin-left:1em"><I></I></FONT><TABLE width="640px" bgcolor="#583927" height="1px" border="0" cellspacing="0" cellpadding="0" style="margin:0px;"><TR><TD></TD></TR></TABLE>
<TABLE width="640px" border="0" cellspacing="0" cellpadding="0">
<TR><TD><CENTER><SPAN class="authors">
Copyright <SPAN class="larger">&#169;</SPAN> 2002-2006
<A href="../mcseem/index.html"><B>Maxim Shemanarev</B></A>
</SPAN></CENTER></TD></TR>
<TR><TD><CENTER><SPAN class="authors">
Web Design and Programming
<A href="../mcseem/index.html"><B>Maxim Shemanarev</B></A>
</SPAN></CENTER></TD></TR>
</TABLE>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
<BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/><BR/>
</HTML>
